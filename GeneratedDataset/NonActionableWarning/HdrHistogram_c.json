[
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Variable \u0027percentiles\u0027 can be declared as pointer to const",
    "cwe": "398",
    "info": "Variable \u0027percentiles\u0027 can be declared as pointer to const",
    "hashId": "4badbf84fa4c397fd59289a5d843b55b2c7bea0f1574312b75a2e834d895e0be",
    "toolName": "cppcheck",
    "warningMessage": "Variable \u0027percentiles\u0027 can be declared as pointer to const",
    "warningSeverity": "style",
    "warningType": "constVariablePointer",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\hdr_histogram.c",
    "lineNumber": "1068",
    "columnNumber": "35",
    "commitId": "f7ae6eee7cb43b83978c2218a0e20647e7faf5e5",
    "commitChildId": "86a01f1e50a910a8c16153950426be2846ddeb70",
    "commitTitle": "Rewrite iterators to use parametric polymorphism.  The same next function and iterator structure is used for all traversal types.  Actual iterator specific data is held in a union and a function pointer is used for next.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/86a01f1e50a910a8c16153950426be2846ddeb70",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/f7ae6eee7cb43b83978c2218a0e20647e7faf5e5/src/hdr_histogram.c#L1068",
    "gitDiffText": "diff --git a/test/hdr_histogram_test.c b/test/hdr_histogram_test.c\nindex 8e8dcae..a40f4e2 100644\n--- a/test/hdr_histogram_test.c\n+++ b/test/hdr_histogram_test.c\n@@ -227,16 +227,16 @@\n static char* test_recorded_values()\n {\n     load_histograms();\n-    struct hdr_recorded_iter iter;\n+    struct hdr_iter iter;\n     int index;\n \n     // Raw Histogram\n-    hdr_recorded_iter_init(\u0026iter, raw_histogram);\n+    hdr_iter_recorded_init(\u0026iter, raw_histogram);\n \n     index \u003d 0;\n-    while (hdr_recorded_iter_next(\u0026iter))\n+    while (hdr_iter_next(\u0026iter))\n     {\n-        int64_t count_added_in_this_bucket \u003d iter.count_added_in_this_iteration_step;\n+        int64_t count_added_in_this_bucket \u003d iter.specifics.recorded.count_added_in_this_iteration_step;\n         if (index \u003d\u003d 0)\n         {\n             mu_assert(\"Value at 0 is not 10000\", count_added_in_this_bucket \u003d\u003d 10000);\n@@ -251,20 +251,20 @@\n     mu_assert(\"Should have encountered 2 values\", index \u003d\u003d 2);\n \n     // Corrected Histogram\n-    hdr_recorded_iter_init(\u0026iter, cor_histogram);\n+    hdr_iter_recorded_init(\u0026iter, cor_histogram);\n \n     index \u003d 0;\n     int64_t total_added_count \u003d 0;\n-    while (hdr_recorded_iter_next(\u0026iter))\n+    while (hdr_iter_next(\u0026iter))\n     {\n-        int64_t count_added_in_this_bucket \u003d iter.count_added_in_this_iteration_step;\n+        int64_t count_added_in_this_bucket \u003d iter.specifics.recorded.count_added_in_this_iteration_step;\n         if (index \u003d\u003d 0)\n         {\n             mu_assert(\"Count at 0 is not 10000\", count_added_in_this_bucket \u003d\u003d 10000);\n         }\n-        mu_assert(\"Count should not be 0\", iter.iter.count_at_index !\u003d 0);\n+        mu_assert(\"Count should not be 0\", iter.count_at_index !\u003d 0);\n         mu_assert(\"Count at value iterated to should be count added in this step\",\n-                  iter.iter.count_at_index \u003d\u003d count_added_in_this_bucket);\n+                  iter.count_at_index \u003d\u003d count_added_in_this_bucket);\n         total_added_count +\u003d count_added_in_this_bucket;\n         index++;\n     }\n@@ -276,15 +276,15 @@\n static char* test_linear_values()\n {\n     load_histograms();\n-    struct hdr_linear_iter iter;\n+    struct hdr_iter iter;\n     int index;\n \n     // Raw Histogram\n-    hdr_linear_iter_init(\u0026iter, raw_histogram, 100000);\n+    hdr_iter_linear_init(\u0026iter, raw_histogram, 100000);\n     index \u003d 0;\n-    while (hdr_linear_iter_next(\u0026iter))\n+    while (hdr_iter_next(\u0026iter))\n     {\n-        int64_t count_added_in_this_bucket \u003d iter.count_added_in_this_iteration_step;\n+        int64_t count_added_in_this_bucket \u003d iter.specifics.linear.count_added_in_this_iteration_step;\n \n         if (index \u003d\u003d 0)\n         {\n@@ -305,12 +305,12 @@\n \n     // Corrected Histogram\n \n-    hdr_linear_iter_init(\u0026iter, cor_histogram, 10000);\n+    hdr_iter_linear_init(\u0026iter, cor_histogram, 10000);\n     index \u003d 0;\n     int64_t total_added_count \u003d 0;\n-    while (hdr_linear_iter_next(\u0026iter))\n+    while (hdr_iter_next(\u0026iter))\n     {\n-        int64_t count_added_in_this_bucket \u003d iter.count_added_in_this_iteration_step;\n+        int64_t count_added_in_this_bucket \u003d iter.specifics.linear.count_added_in_this_iteration_step;\n \n         if (index \u003d\u003d 0)\n         {\n@@ -329,15 +329,15 @@\n static char* test_logarithmic_values()\n {\n     load_histograms();\n-    struct hdr_log_iter iter;\n+    struct hdr_iter iter;\n     int index;\n \n-    hdr_log_iter_init(\u0026iter, raw_histogram, 10000, 2.0);\n+    hdr_iter_log_init(\u0026iter, raw_histogram, 10000, 2.0);\n     index \u003d 0;\n \n-    while(hdr_log_iter_next(\u0026iter))\n+    while(hdr_iter_next(\u0026iter))\n     {\n-        long count_added_in_this_bucket \u003d iter.count_added_in_this_iteration_step;\n+        long count_added_in_this_bucket \u003d iter.specifics.log.count_added_in_this_iteration_step;\n         if (index \u003d\u003d 0)\n         {\n             mu_assert(\"Raw Logarithmic 10 msec bucket # 0 added a count of 10000\", 10000 \u003d\u003d count_added_in_this_bucket);\n@@ -356,12 +356,12 @@\n \n     mu_assert(\"Should of seen 14 values\", index - 1 \u003d\u003d 14);\n \n-    hdr_log_iter_init(\u0026iter, cor_histogram, 10000, 2.0);\n+    hdr_iter_log_init(\u0026iter, cor_histogram, 10000, 2.0);\n     index \u003d 0;\n     int total_added_count \u003d 0;\n-    while (hdr_log_iter_next(\u0026iter))\n+    while (hdr_iter_next(\u0026iter))\n     {\n-        long count_added_in_this_bucket \u003d iter.count_added_in_this_iteration_step;\n+        long count_added_in_this_bucket \u003d iter.specifics.log.count_added_in_this_iteration_step;\n \n         if (index \u003d\u003d 0)\n         {\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cfloat.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "06d10470a8a3dec17c821a15d1b1f61b5cab9fae40ebf2d39bc52f4364522bfd",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cfloat.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\hdr_dbl_histogram.c",
    "lineNumber": "11",
    "columnNumber": "0",
    "commitId": "d49e91abb96f06d6e89cd32d8e482be21b1e4eb4",
    "commitChildId": "cff971e839f1ccad3bfa89325c4a59b3ebc438f2",
    "commitTitle": "[C] More work on hdr_dbl_histogram, range adjustment now works and now have a couple of passing unit tests.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cff971e839f1ccad3bfa89325c4a59b3ebc438f2",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/d49e91abb96f06d6e89cd32d8e482be21b1e4eb4/src/hdr_dbl_histogram.c#L11",
    "gitDiffText": "diff --git a/test/hdr_dbl_histogram_test.c b/test/hdr_dbl_histogram_test.c\nindex faa18f3..6ba5454 100644\n--- a/test/hdr_dbl_histogram_test.c\n+++ b/test/hdr_dbl_histogram_test.c\n@@ -69,8 +69,8 @@\n \n static struct mu_result all_tests()\n {\n-    //mu_run_test(test_construct_argument_ranges);\n-    //mu_run_test(test_construction_argument_gets);\n+    mu_run_test(test_construct_argument_ranges);\n+    mu_run_test(test_construction_argument_gets);\n \n     mu_ok;\n }\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Parameter \u0027base64_histogram\u0027 can be declared as pointer to const",
    "cwe": "398",
    "info": "Parameter \u0027base64_histogram\u0027 can be declared as pointer to const",
    "hashId": "d7abf4730da3c31489a1d7c5a644c834e54f72dcc98dea5d91a75a915ee9173d",
    "toolName": "cppcheck",
    "warningMessage": "Parameter \u0027base64_histogram\u0027 can be declared as pointer to const",
    "warningSeverity": "style",
    "warningType": "constParameterPointer",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\hdr_histogram_log.c",
    "lineNumber": "1002",
    "columnNumber": "60",
    "commitId": "2fcf3806acfe5702b2e7e5242acb690aa1ed28ae",
    "commitChildId": "52f53d9e4aada645f2edc8bc36b13bbe96ce9096",
    "commitTitle": "Add API to encode/decode hdr_histogram into base64 char.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/52f53d9e4aada645f2edc8bc36b13bbe96ce9096",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/2fcf3806acfe5702b2e7e5242acb690aa1ed28ae/src/hdr_histogram_log.c#L1002",
    "gitDiffText": "diff --git a/test/hdr_histogram_log_test.c b/test/hdr_histogram_log_test.c\nindex 7b7512b..a9b9270 100644\n--- a/test/hdr_histogram_log_test.c\n+++ b/test/hdr_histogram_log_test.c\n@@ -550,6 +550,24 @@\n     return 0;\n }\n \n+static char* test_string_encode_decode()\n+{\n+\tstruct hdr_histogram *histogram, *hdr_new \u003d NULL;\n+\thdr_alloc(3600L * 1000 * 1000, 3, \u0026histogram);\n+\n+\tfor (int i \u003d 1; i \u003c 100; i++) {\n+\t\thdr_record_value(histogram, i*i);\n+\t}\n+\n+\tchar *data;\n+\n+\tmu_assert(\"failed to encode histogram data\", hdr_log_encode(histogram, \u0026data) \u003d\u003d 0);\n+\tmu_assert(\"failed to decode histogram data\", hdr_log_decode(\u0026hdr_new, data, strlen(data)) \u003d\u003d 0);\n+\n+\tmu_assert(\"failed to be equal histogram after encode/decode\", hdr_mean(histogram) \u003d\u003d hdr_mean(hdr_new));\n+\n+\treturn 0;\n+}\n \n static struct mu_result all_tests()\n {\n@@ -572,6 +590,8 @@\n     mu_run_test(log_reader_aggregates_into_single_histogram);\n     mu_run_test(log_reader_fails_with_incorrect_version);\n \n+\tmu_run_test(test_string_encode_decode);\n+\n     free(raw_histogram);\n     free(cor_histogram);\n \n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Parameter \u0027cfg\u0027 can be declared as pointer to const",
    "cwe": "398",
    "info": "Parameter \u0027cfg\u0027 can be declared as pointer to const",
    "hashId": "f084dc5f8f2c95a8dcc477de25586d26a155b2fb490476dec3f042fdc21ab453",
    "toolName": "cppcheck",
    "warningMessage": "Parameter \u0027cfg\u0027 can be declared as pointer to const",
    "warningSeverity": "style",
    "warningType": "constParameterPointer",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\hdr_histogram.c",
    "lineNumber": "297",
    "columnNumber": "89",
    "commitId": "9b49de44ee0d64ec3fba34cbd5f0e55b759ac36e",
    "commitChildId": "37fd87a089d83d8b8fcc1a87cd29f324081769c9",
    "commitTitle": "[C] Partial implementation of test and record single value for double histogram.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/37fd87a089d83d8b8fcc1a87cd29f324081769c9",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/9b49de44ee0d64ec3fba34cbd5f0e55b759ac36e/src/main/c/hdr_histogram.c#L297",
    "gitDiffText": "diff --git a/src/test/c/minunit.h b/src/test/c/minunit.h\nindex 052846d..e27f686 100644\n--- a/src/test/c/minunit.h\n+++ b/src/test/c/minunit.h\n@@ -36,3 +36,15 @@\n     } while (0)\n \n extern int tests_run;\n+\n+bool compare_double(double a, double b, double delta)\n+{\n+    if (fabs(a - b) \u003c delta)\n+    {\n+        return true;\n+    }\n+\n+    printf(\"[compare_double] fabs(%f, %f) \u003c %f \u003d\u003d false\\n\", a, b, delta);\n+    return false;\n+}\n+\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Identical condition and return expression \u0027rc\u0027, return value is always 0",
    "cwe": "398",
    "info": "Returning identical expression \u0027rc\u0027",
    "hashId": "21a2da6ef30b3c38651611c30be3a7aeab78dec285f083840a859ad535ff83fd",
    "toolName": "cppcheck",
    "warningMessage": "Identical condition and return expression \u0027rc\u0027, return value is always 0",
    "warningSeverity": "warning",
    "warningType": "identicalConditionAfterEarlyExit",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\hdr_atomic_histogram.c",
    "lineNumber": "54",
    "columnNumber": "12",
    "commitId": "3ca7629b51cd0f24b7cd900cf5692c3185202997",
    "commitChildId": "38773c8de4109fa9c2036b8ca703bd7ed2617bb8",
    "commitTitle": "[C] Add atomic histogram.  Clean up warnings.  Materialise imports on headers.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/38773c8de4109fa9c2036b8ca703bd7ed2617bb8",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/3ca7629b51cd0f24b7cd900cf5692c3185202997/src/main/c/hdr_atomic_histogram.c#L54",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_test.c b/src/test/c/hdr_histogram_test.c\nindex 6cfccb6..edb7cfc 100644\n--- a/src/test/c/hdr_histogram_test.c\n+++ b/src/test/c/hdr_histogram_test.c\n@@ -484,23 +484,5 @@\n \n     printf(\"Tests run: %d\\n\", tests_run);\n \n-    return result.message;\n-}\n-\n-// int main(int argc, char **argv)\n-// {\n-//     struct mu_result result \u003d all_tests();\n-\n-//     if (result.message !\u003d 0)\n-//     {\n-//         printf(\"%s(): %s\\n\", result.test, result.message);\n-//     }\n-//     else\n-//     {\n-//         printf(\"ALL TESTS PASSED\\n\");\n-//     }\n-\n-//     printf(\"Tests run: %d\\n\", tests_run);\n-\n-//     return result.message !\u003d 0;\n-// }\n+    return (int) result.message;\n+}\n\\ No newline at end of file\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Identical condition and return expression \u0027rc\u0027, return value is always 0",
    "cwe": "398",
    "info": "If condition \u0027rc\u0027 is true, the function will return/exit",
    "hashId": "21a2da6ef30b3c38651611c30be3a7aeab78dec285f083840a859ad535ff83fd",
    "toolName": "cppcheck",
    "warningMessage": "Identical condition and return expression \u0027rc\u0027, return value is always 0",
    "warningSeverity": "warning",
    "warningType": "identicalConditionAfterEarlyExit",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\hdr_atomic_histogram.c",
    "lineNumber": "45",
    "columnNumber": "9",
    "commitId": "3ca7629b51cd0f24b7cd900cf5692c3185202997",
    "commitChildId": "38773c8de4109fa9c2036b8ca703bd7ed2617bb8",
    "commitTitle": "[C] Add atomic histogram.  Clean up warnings.  Materialise imports on headers.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/38773c8de4109fa9c2036b8ca703bd7ed2617bb8",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/3ca7629b51cd0f24b7cd900cf5692c3185202997/src/main/c/hdr_atomic_histogram.c#L45",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_test.c b/src/test/c/hdr_histogram_test.c\nindex 6cfccb6..edb7cfc 100644\n--- a/src/test/c/hdr_histogram_test.c\n+++ b/src/test/c/hdr_histogram_test.c\n@@ -484,23 +484,5 @@\n \n     printf(\"Tests run: %d\\n\", tests_run);\n \n-    return result.message;\n-}\n-\n-// int main(int argc, char **argv)\n-// {\n-//     struct mu_result result \u003d all_tests();\n-\n-//     if (result.message !\u003d 0)\n-//     {\n-//         printf(\"%s(): %s\\n\", result.test, result.message);\n-//     }\n-//     else\n-//     {\n-//         printf(\"ALL TESTS PASSED\\n\");\n-//     }\n-\n-//     printf(\"Tests run: %d\\n\", tests_run);\n-\n-//     return result.message !\u003d 0;\n-// }\n+    return (int) result.message;\n+}\n\\ No newline at end of file\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003chdr_dbl_histogram.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "20237f59c72529bc876034f179417fe319838709b2304c08d82618201a94342c",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003chdr_dbl_histogram.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\hdr_dbl_histogram.c",
    "lineNumber": "7",
    "columnNumber": "0",
    "commitId": "d073caf61e137808b2e6b1d8ad1a0fd9ae85c62b",
    "commitChildId": "0017aa8f889d7bd379a8d3260419cc01dbe86f44",
    "commitTitle": "[C] Fix multiple build errors/warning on Mac OS X",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/0017aa8f889d7bd379a8d3260419cc01dbe86f44",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/d073caf61e137808b2e6b1d8ad1a0fd9ae85c62b/src/main/c/hdr_dbl_histogram.c#L7",
    "gitDiffText": "diff --git a/src/test/c/CMakeLists.txt b/src/test/c/CMakeLists.txt\nindex f3226fe..715989b 100644\n--- a/src/test/c/CMakeLists.txt\n+++ b/src/test/c/CMakeLists.txt\n@@ -1,9 +1,16 @@\n-\n+INCLUDE(CheckLibraryExists)\n \n add_executable(testing hdr_histogram_test.c hdr_histogram_log_test.c hdr_dbl_histogram_test.c main_test.c)\n-target_link_libraries(testing hdr_histogram m rt z)\n-install(TARGETS testing DESTINATION bin)\n-\n add_executable(perftest hdr_histogram_perf.c)\n-target_link_libraries(perftest hdr_histogram m rt z)\n+\n+target_link_libraries(testing hdr_histogram m z)\n+target_link_libraries(perftest hdr_histogram m z)\n+\n+CHECK_LIBRARY_EXISTS(rt clock_gettime \"\" RT_EXISTS)\n+if (RT_EXISTS)\n+    target_link_libraries(testing rt)\n+    target_link_libraries(perftest rt)\n+endif (RT_EXISTS)\n+\n+install(TARGETS testing DESTINATION bin)\n install(TARGETS perftest DESTINATION bin)\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003chdr_interval_recorder.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "20a87cbb4e366ca6d7fb819a9743df2dea64e45668f5cd2b098bb971e1080b7a",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003chdr_interval_recorder.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\examples\\c\\hiccup.c",
    "lineNumber": "18",
    "columnNumber": "0",
    "commitId": "d4ec15de1ab74cb02883d53f45d97367c9ff6ffa",
    "commitChildId": "6cfd04978a0b972dfe8b01e1bb6a799fc5b5e142",
    "commitTitle": "[C] Add hdr_interval_recorder and update hiccup example to use it.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/6cfd04978a0b972dfe8b01e1bb6a799fc5b5e142",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/d4ec15de1ab74cb02883d53f45d97367c9ff6ffa/src/examples/c/hiccup.c#L18",
    "gitDiffText": "diff --git a/src/main/c/hdr_writer_reader_phaser.h b/src/main/c/hdr_writer_reader_phaser.h\nindex 22bc8f3..036856c 100644\n--- a/src/main/c/hdr_writer_reader_phaser.h\n+++ b/src/main/c/hdr_writer_reader_phaser.h\n@@ -4,6 +4,9 @@\n  * as explained at http://creativecommons.org/publicdomain/zero/1.0/\n  */\n \n+#ifndef HDR_WRITER_READER_PHASER_H\n+#define HDR_WRITER_READER_PHASER_H 1\n+\n #include \u003cstdbool.h\u003e\n #include \u003cstdlib.h\u003e\n \n@@ -152,4 +155,6 @@\n         }\n     }\n     while (!caught_up);\n-}\n\\ No newline at end of file\n+}\n+\n+#endif\n\\ No newline at end of file\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cpthread.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "853fed2810c647c81b07702bb018921dbdbf068db2c003fb6f6e8dac2c1cf664",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cpthread.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\examples\\c\\hiccup.c",
    "lineNumber": "5",
    "columnNumber": "0",
    "commitId": "bd4a064af71c654a2917bded5121a529b136b6dd",
    "commitChildId": "0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "commitTitle": "[C] Add simple hiccup monitor to demo hdr_writer_reader_phaser.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/bd4a064af71c654a2917bded5121a529b136b6dd/src/examples/c/hiccup.c#L5",
    "gitDiffText": "diff --git a/src/main/c/hdr_writer_reader_phaser.h b/src/main/c/hdr_writer_reader_phaser.h\nindex 2ddd5d9..844b7a9 100644\n--- a/src/main/c/hdr_writer_reader_phaser.h\n+++ b/src/main/c/hdr_writer_reader_phaser.h\n@@ -56,7 +56,7 @@\n \n \tp-\u003estart_epoch._nonatomic \u003d 0;\n \tp-\u003eeven_end_epoch._nonatomic \u003d 0;\n-\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MAX;\n+\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MIN;\n \tp-\u003ereader_mutex \u003d malloc(sizeof(mint_mutex_t));\n \n \tif (!p-\u003ereader_mutex)\n@@ -127,7 +127,7 @@\n \t}\n \telse\n \t{\n-\t\tinitial_start_value \u003d INT64_MAX;\n+\t\tinitial_start_value \u003d INT64_MIN;\n \t\t_hdr_phaser_set_epoch(\u0026p-\u003eodd_end_epoch, initial_start_value);\n \t}\n \n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003csys/timerfd.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "d98ca975258787a82c8cd516f5dba86653cf68ee9dc996df2f6368e268da1fee",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003csys/timerfd.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\examples\\c\\hiccup.c",
    "lineNumber": "6",
    "columnNumber": "0",
    "commitId": "bd4a064af71c654a2917bded5121a529b136b6dd",
    "commitChildId": "0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "commitTitle": "[C] Add simple hiccup monitor to demo hdr_writer_reader_phaser.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/bd4a064af71c654a2917bded5121a529b136b6dd/src/examples/c/hiccup.c#L6",
    "gitDiffText": "diff --git a/src/main/c/hdr_writer_reader_phaser.h b/src/main/c/hdr_writer_reader_phaser.h\nindex 2ddd5d9..844b7a9 100644\n--- a/src/main/c/hdr_writer_reader_phaser.h\n+++ b/src/main/c/hdr_writer_reader_phaser.h\n@@ -56,7 +56,7 @@\n \n \tp-\u003estart_epoch._nonatomic \u003d 0;\n \tp-\u003eeven_end_epoch._nonatomic \u003d 0;\n-\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MAX;\n+\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MIN;\n \tp-\u003ereader_mutex \u003d malloc(sizeof(mint_mutex_t));\n \n \tif (!p-\u003ereader_mutex)\n@@ -127,7 +127,7 @@\n \t}\n \telse\n \t{\n-\t\tinitial_start_value \u003d INT64_MAX;\n+\t\tinitial_start_value \u003d INT64_MIN;\n \t\t_hdr_phaser_set_epoch(\u0026p-\u003eodd_end_epoch, initial_start_value);\n \t}\n \n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cpoll.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "6fe32ca9b9781d3faae4b9c15ef5d52e69c4c8a3bdbdde9cec4d66dcf929b1bc",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cpoll.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\examples\\c\\hiccup.c",
    "lineNumber": "7",
    "columnNumber": "0",
    "commitId": "bd4a064af71c654a2917bded5121a529b136b6dd",
    "commitChildId": "0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "commitTitle": "[C] Add simple hiccup monitor to demo hdr_writer_reader_phaser.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/bd4a064af71c654a2917bded5121a529b136b6dd/src/examples/c/hiccup.c#L7",
    "gitDiffText": "diff --git a/src/main/c/hdr_writer_reader_phaser.h b/src/main/c/hdr_writer_reader_phaser.h\nindex 2ddd5d9..844b7a9 100644\n--- a/src/main/c/hdr_writer_reader_phaser.h\n+++ b/src/main/c/hdr_writer_reader_phaser.h\n@@ -56,7 +56,7 @@\n \n \tp-\u003estart_epoch._nonatomic \u003d 0;\n \tp-\u003eeven_end_epoch._nonatomic \u003d 0;\n-\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MAX;\n+\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MIN;\n \tp-\u003ereader_mutex \u003d malloc(sizeof(mint_mutex_t));\n \n \tif (!p-\u003ereader_mutex)\n@@ -127,7 +127,7 @@\n \t}\n \telse\n \t{\n-\t\tinitial_start_value \u003d INT64_MAX;\n+\t\tinitial_start_value \u003d INT64_MIN;\n \t\t_hdr_phaser_set_epoch(\u0026p-\u003eodd_end_epoch, initial_start_value);\n \t}\n \n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003csignal.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "3c7dc71bea638745baac136df6e5928f2c8203aaf42cce175227362cca5a4aad",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003csignal.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\examples\\c\\hiccup.c",
    "lineNumber": "9",
    "columnNumber": "0",
    "commitId": "bd4a064af71c654a2917bded5121a529b136b6dd",
    "commitChildId": "0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "commitTitle": "[C] Add simple hiccup monitor to demo hdr_writer_reader_phaser.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/bd4a064af71c654a2917bded5121a529b136b6dd/src/examples/c/hiccup.c#L9",
    "gitDiffText": "diff --git a/src/main/c/hdr_writer_reader_phaser.h b/src/main/c/hdr_writer_reader_phaser.h\nindex 2ddd5d9..844b7a9 100644\n--- a/src/main/c/hdr_writer_reader_phaser.h\n+++ b/src/main/c/hdr_writer_reader_phaser.h\n@@ -56,7 +56,7 @@\n \n \tp-\u003estart_epoch._nonatomic \u003d 0;\n \tp-\u003eeven_end_epoch._nonatomic \u003d 0;\n-\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MAX;\n+\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MIN;\n \tp-\u003ereader_mutex \u003d malloc(sizeof(mint_mutex_t));\n \n \tif (!p-\u003ereader_mutex)\n@@ -127,7 +127,7 @@\n \t}\n \telse\n \t{\n-\t\tinitial_start_value \u003d INT64_MAX;\n+\t\tinitial_start_value \u003d INT64_MIN;\n \t\t_hdr_phaser_set_epoch(\u0026p-\u003eodd_end_epoch, initial_start_value);\n \t}\n \n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003chdr_time.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "bca5b95b1c6a89e4b5687a543605c0a75f4f86cb884b137da5def7f0ab9a1c55",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003chdr_time.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\examples\\c\\hiccup.c",
    "lineNumber": "13",
    "columnNumber": "0",
    "commitId": "bd4a064af71c654a2917bded5121a529b136b6dd",
    "commitChildId": "0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "commitTitle": "[C] Add simple hiccup monitor to demo hdr_writer_reader_phaser.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/bd4a064af71c654a2917bded5121a529b136b6dd/src/examples/c/hiccup.c#L13",
    "gitDiffText": "diff --git a/src/main/c/hdr_writer_reader_phaser.h b/src/main/c/hdr_writer_reader_phaser.h\nindex 2ddd5d9..844b7a9 100644\n--- a/src/main/c/hdr_writer_reader_phaser.h\n+++ b/src/main/c/hdr_writer_reader_phaser.h\n@@ -56,7 +56,7 @@\n \n \tp-\u003estart_epoch._nonatomic \u003d 0;\n \tp-\u003eeven_end_epoch._nonatomic \u003d 0;\n-\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MAX;\n+\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MIN;\n \tp-\u003ereader_mutex \u003d malloc(sizeof(mint_mutex_t));\n \n \tif (!p-\u003ereader_mutex)\n@@ -127,7 +127,7 @@\n \t}\n \telse\n \t{\n-\t\tinitial_start_value \u003d INT64_MAX;\n+\t\tinitial_start_value \u003d INT64_MIN;\n \t\t_hdr_phaser_set_epoch(\u0026p-\u003eodd_end_epoch, initial_start_value);\n \t}\n \n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Signed integer overflow for expression \u002724L*60*60*1000000\u0027.",
    "cwe": "190",
    "info": "Integer overflow",
    "hashId": "aa718dfef7cfccc90b97fbfcb0d399dc7a03ac835545354e197a768400e01acd",
    "toolName": "cppcheck",
    "warningMessage": "Signed integer overflow for expression \u002724L*60*60*1000000\u0027.",
    "warningSeverity": "error",
    "warningType": "integerOverflow",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\examples\\c\\hiccup.c",
    "lineNumber": "107",
    "columnNumber": "20",
    "commitId": "bd4a064af71c654a2917bded5121a529b136b6dd",
    "commitChildId": "0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "commitTitle": "[C] Add simple hiccup monitor to demo hdr_writer_reader_phaser.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/bd4a064af71c654a2917bded5121a529b136b6dd/src/examples/c/hiccup.c#L107",
    "gitDiffText": "diff --git a/src/main/c/hdr_writer_reader_phaser.h b/src/main/c/hdr_writer_reader_phaser.h\nindex 2ddd5d9..844b7a9 100644\n--- a/src/main/c/hdr_writer_reader_phaser.h\n+++ b/src/main/c/hdr_writer_reader_phaser.h\n@@ -56,7 +56,7 @@\n \n \tp-\u003estart_epoch._nonatomic \u003d 0;\n \tp-\u003eeven_end_epoch._nonatomic \u003d 0;\n-\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MAX;\n+\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MIN;\n \tp-\u003ereader_mutex \u003d malloc(sizeof(mint_mutex_t));\n \n \tif (!p-\u003ereader_mutex)\n@@ -127,7 +127,7 @@\n \t}\n \telse\n \t{\n-\t\tinitial_start_value \u003d INT64_MAX;\n+\t\tinitial_start_value \u003d INT64_MIN;\n \t\t_hdr_phaser_set_epoch(\u0026p-\u003eodd_end_epoch, initial_start_value);\n \t}\n \n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Signed integer overflow for expression \u002724L*60*60*1000000\u0027.",
    "cwe": "190",
    "info": "Integer overflow",
    "hashId": "aa718dfef7cfccc90b97fbfcb0d399dc7a03ac835545354e197a768400e01acd",
    "toolName": "cppcheck",
    "warningMessage": "Signed integer overflow for expression \u002724L*60*60*1000000\u0027.",
    "warningSeverity": "error",
    "warningType": "integerOverflow",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\examples\\c\\hiccup.c",
    "lineNumber": "111",
    "columnNumber": "20",
    "commitId": "bd4a064af71c654a2917bded5121a529b136b6dd",
    "commitChildId": "0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "commitTitle": "[C] Add simple hiccup monitor to demo hdr_writer_reader_phaser.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/bd4a064af71c654a2917bded5121a529b136b6dd/src/examples/c/hiccup.c#L111",
    "gitDiffText": "diff --git a/src/main/c/hdr_writer_reader_phaser.h b/src/main/c/hdr_writer_reader_phaser.h\nindex 2ddd5d9..844b7a9 100644\n--- a/src/main/c/hdr_writer_reader_phaser.h\n+++ b/src/main/c/hdr_writer_reader_phaser.h\n@@ -56,7 +56,7 @@\n \n \tp-\u003estart_epoch._nonatomic \u003d 0;\n \tp-\u003eeven_end_epoch._nonatomic \u003d 0;\n-\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MAX;\n+\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MIN;\n \tp-\u003ereader_mutex \u003d malloc(sizeof(mint_mutex_t));\n \n \tif (!p-\u003ereader_mutex)\n@@ -127,7 +127,7 @@\n \t}\n \telse\n \t{\n-\t\tinitial_start_value \u003d INT64_MAX;\n+\t\tinitial_start_value \u003d INT64_MIN;\n \t\t_hdr_phaser_set_epoch(\u0026p-\u003eodd_end_epoch, initial_start_value);\n \t}\n \n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \"hdr_time.h\" not found.",
    "hashId": "cf085b44217209f559bee32059c0ea3c2d43868ad6894d7fdc7f88d65cf7b964",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \"hdr_time.h\" not found.",
    "warningSeverity": "information",
    "warningType": "missingInclude",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\test\\c\\hdr_histogram_perf.c",
    "lineNumber": "11",
    "columnNumber": "0",
    "commitId": "bd4a064af71c654a2917bded5121a529b136b6dd",
    "commitChildId": "0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "commitTitle": "[C] Add simple hiccup monitor to demo hdr_writer_reader_phaser.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/bd4a064af71c654a2917bded5121a529b136b6dd/src/test/c/hdr_histogram_perf.c#L11",
    "gitDiffText": "diff --git a/src/main/c/hdr_writer_reader_phaser.h b/src/main/c/hdr_writer_reader_phaser.h\nindex 2ddd5d9..844b7a9 100644\n--- a/src/main/c/hdr_writer_reader_phaser.h\n+++ b/src/main/c/hdr_writer_reader_phaser.h\n@@ -56,7 +56,7 @@\n \n \tp-\u003estart_epoch._nonatomic \u003d 0;\n \tp-\u003eeven_end_epoch._nonatomic \u003d 0;\n-\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MAX;\n+\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MIN;\n \tp-\u003ereader_mutex \u003d malloc(sizeof(mint_mutex_t));\n \n \tif (!p-\u003ereader_mutex)\n@@ -127,7 +127,7 @@\n \t}\n \telse\n \t{\n-\t\tinitial_start_value \u003d INT64_MAX;\n+\t\tinitial_start_value \u003d INT64_MIN;\n \t\t_hdr_phaser_set_epoch(\u0026p-\u003eodd_end_epoch, initial_start_value);\n \t}\n \n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \"hdr_time.h\" not found.",
    "hashId": "2503614b41afab1185a2b81e9d4f74b6a83d442bdd3da163300ddf90f280036e",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \"hdr_time.h\" not found.",
    "warningSeverity": "information",
    "warningType": "missingInclude",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\test\\c\\hdr_histogram_log_test.c",
    "lineNumber": "17",
    "columnNumber": "0",
    "commitId": "bd4a064af71c654a2917bded5121a529b136b6dd",
    "commitChildId": "0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "commitTitle": "[C] Add simple hiccup monitor to demo hdr_writer_reader_phaser.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/0d70789da2b4fb1d6128282ca657b295daa5e2b7",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/bd4a064af71c654a2917bded5121a529b136b6dd/src/test/c/hdr_histogram_log_test.c#L17",
    "gitDiffText": "diff --git a/src/main/c/hdr_writer_reader_phaser.h b/src/main/c/hdr_writer_reader_phaser.h\nindex 2ddd5d9..844b7a9 100644\n--- a/src/main/c/hdr_writer_reader_phaser.h\n+++ b/src/main/c/hdr_writer_reader_phaser.h\n@@ -56,7 +56,7 @@\n \n \tp-\u003estart_epoch._nonatomic \u003d 0;\n \tp-\u003eeven_end_epoch._nonatomic \u003d 0;\n-\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MAX;\n+\tp-\u003eodd_end_epoch._nonatomic \u003d INT64_MIN;\n \tp-\u003ereader_mutex \u003d malloc(sizeof(mint_mutex_t));\n \n \tif (!p-\u003ereader_mutex)\n@@ -127,7 +127,7 @@\n \t}\n \telse\n \t{\n-\t\tinitial_start_value \u003d INT64_MAX;\n+\t\tinitial_start_value \u003d INT64_MIN;\n \t\t_hdr_phaser_set_epoch(\u0026p-\u003eodd_end_epoch, initial_start_value);\n \t}\n \n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintsystem/datetime.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "d0cea8dfe23f974734b88d081b735d61c3882a2346ecae2342e4b2ba4a67fad0",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintsystem/datetime.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintsystem\\gcc\\datetime.c",
    "lineNumber": "1",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintsystem/gcc/datetime.c#L1",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003csys/time.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "6282d026db929fe49a8242e050dab647de7e04283f417ee2ec154bc0eef8c42a",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003csys/time.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintsystem\\gcc\\datetime.c",
    "lineNumber": "5",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintsystem/gcc/datetime.c#L5",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintsystem/mutex.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "f56efd770c0f54d7096afc352a4f70246c70f5039d575b1e5c9f6fb39217e00d",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintsystem/mutex.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintsystem\\gcc\\mutex.c",
    "lineNumber": "1",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintsystem/gcc/mutex.c#L1",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/lwlogger.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "8488c6355ebd74e2b363e25cb4e5ddcb623bc93c126ca4113393b8a70a406575",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/lwlogger.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintpack\\lwlogger.cpp",
    "lineNumber": "1",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintpack/lwlogger.cpp#L1",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "211ff16b4fb4c003e64476c318da85cf048665d51f72f4cb6317a94d9b20ddd4",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintpack\\timewaster.cpp",
    "lineNumber": "1",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintpack/timewaster.cpp#L1",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/timewaster.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "7582cef1d2b496000c1dc6fb1048bcfda42c799ed43af1ae1ccc0bc61b4452e4",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/timewaster.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintpack\\timewaster.cpp",
    "lineNumber": "2",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintpack/timewaster.cpp#L2",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/random.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "62938e0666f1d3d1d6b1faff6ce6513f63d7d80c6a00f6b9c5fceacfc37d57df",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/random.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintpack\\random.cpp",
    "lineNumber": "1",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintpack/random.cpp#L1",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintsystem/datetime.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "ec210e8673a661fc17849931cbe02b135b42346d75c1e08076ee299e3129e4fa",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintsystem/datetime.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintpack\\random.cpp",
    "lineNumber": "2",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintpack/random.cpp#L2",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/threadsynchronizer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "290ae4e376ddc059da8557557f97c8e53ff1fe86ba61a7ef95c86c27a1aee53c",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/threadsynchronizer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintpack\\threadsynchronizer.cpp",
    "lineNumber": "1",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintpack/threadsynchronizer.cpp#L1",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintsystem/timer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "09f9e1e9c1231110ee916fd21603e0ccb6858e626c9638cab157107abcbc6f76",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintsystem/timer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintpack\\threadsynchronizer.cpp",
    "lineNumber": "2",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintpack/threadsynchronizer.cpp#L2",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "052d54e83e19ae7ce12df4ec04dc11c8c28384184177fc624252fa6d2de08647",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintpack\\threadsynchronizer.cpp",
    "lineNumber": "3",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintpack/threadsynchronizer.cpp#L3",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintomic/core.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "5dd54289c12dd213dd7a6bf6ebd96c5e9f684180e735b7f6e3dedb9135227e4d",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintomic/core.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintomic\\mintomic_gcc.c",
    "lineNumber": "1",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintomic/mintomic_gcc.c#L1",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintsystem/timer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "c176f539c281045e5b0c353c323084e783dbe98f4f5697d656b5bab3f6f595fc",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintsystem/timer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintpack\\random.cpp",
    "lineNumber": "3",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintpack/random.cpp#L3",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintsystem/tid.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "c4dfda9a684653d7e378a5720cbb745b0c9d0c679043b764b15329724d7f16dc",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintsystem/tid.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintpack\\random.cpp",
    "lineNumber": "4",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintpack/random.cpp#L4",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintsystem/datetime.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "2edd87fc214f1f07a5526fd27b5d6486e1f5edd532f5a1ad2a00bd48a73cdf41",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintsystem/datetime.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintsystem\\msvc\\datetime.c",
    "lineNumber": "1",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintsystem/msvc/datetime.c#L1",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintsystem/timer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "46c67417e13678043e5b1bf2be247d79ca91df059ad498b10fbd0705d586c844",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintsystem/timer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintsystem\\gcc\\timer.c",
    "lineNumber": "1",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintsystem/gcc/timer.c#L1",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintsystem/semaphore.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "c60a1d30d0f399b957060f4e6a6ff46a7e85252fbac2cc5efd9c84531e0e9049",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintsystem/semaphore.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintsystem\\gcc\\semaphore.c",
    "lineNumber": "1",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintsystem/gcc/semaphore.c#L1",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Variable \u0027largeInteger.LowPart\u0027 is assigned a value that is never used.",
    "cwe": "563",
    "hashId": "c51a9fb4d9123d1999337d705f583dc446a046fbd05cbe363492269a3ce2fbe5",
    "toolName": "cppcheck",
    "warningMessage": "Variable \u0027largeInteger.LowPart\u0027 is assigned a value that is never used.",
    "warningSeverity": "style",
    "warningType": "unreadVariable",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintsystem\\msvc\\datetime.c",
    "lineNumber": "10",
    "columnNumber": "26",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintsystem/msvc/datetime.c#L10",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Variable \u0027largeInteger.HighPart\u0027 is assigned a value that is never used.",
    "cwe": "563",
    "hashId": "398524308ef11dafc5f24674dd40061652eded10a08655497a8b1916311bbd10",
    "toolName": "cppcheck",
    "warningMessage": "Variable \u0027largeInteger.HighPart\u0027 is assigned a value that is never used.",
    "warningSeverity": "style",
    "warningType": "unreadVariable",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintsystem\\msvc\\datetime.c",
    "lineNumber": "11",
    "columnNumber": "27",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintsystem/msvc/datetime.c#L11",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "5b05b601a159231d1a5633e85864b5bb37ba4b5c05702cdfe8b42664bdaed29a",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintsystem\\msvc\\thread.c",
    "lineNumber": "1",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintsystem/msvc/thread.c#L1",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintsystem/thread.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "787c3b9666f38819fcd5a663e41db149f581b3c5366ae55729d21cd12164a599",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintsystem/thread.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintsystem\\msvc\\thread.c",
    "lineNumber": "2",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintsystem/msvc/thread.c#L2",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmalloc.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "2260d9422c00eac3f152e9e27deb391d433857498d19019c80c37152d759cf51",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmalloc.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintsystem\\msvc\\thread.c",
    "lineNumber": "4",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintsystem/msvc/thread.c#L4",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintsystem/timer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "a282839eb44a19e9618e4a497e552ddbb2b012888bec8b3296d44b6f8a5bda18",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintsystem/timer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintsystem\\msvc\\timer.c",
    "lineNumber": "1",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintsystem/msvc/timer.c#L1",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Variable \u0027y\u0027 is assigned a value that is never used.",
    "cwe": "563",
    "hashId": "cd6a8e0f10309433c96d705827322897881700c8bad6e5ec03332a2e86574394",
    "toolName": "cppcheck",
    "warningMessage": "Variable \u0027y\u0027 is assigned a value that is never used.",
    "warningSeverity": "style",
    "warningType": "unreadVariable",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintsystem\\gcc\\semaphore.c",
    "lineNumber": "42",
    "columnNumber": "15",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintsystem/gcc/semaphore.c#L42",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "64e668a6644c89381b6bb7b7422ad991ce0cdf2dd348a4dd76d2da8abef89ade",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintsystem\\gcc\\semaphore.c",
    "lineNumber": "5",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintsystem/gcc/semaphore.c#L5",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cunistd.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "be7981e188bea648233b165f0f713f48e3b05d2ffa80924da05c205f502dae75",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cunistd.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintsystem\\gcc\\semaphore.c",
    "lineNumber": "7",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintsystem/gcc/semaphore.c#L7",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time.",
    "cwe": "398",
    "hashId": "25405e4176150a48d46b0ef8aaf8d6255e74b0d5e61e342b62553056e9b9bab1",
    "toolName": "cppcheck",
    "warningMessage": "Too many #ifdef configurations - cppcheck only checks 12 of 66 configurations. Use --force to check all configurations.",
    "warningSeverity": "information",
    "warningType": "toomanyconfigs",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\CMakeFiles\\2.8.12.2\\CompilerIdC\\CMakeCCompilerId.c",
    "lineNumber": "0",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c#L0",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected.",
    "cwe": "398",
    "hashId": "5dd726d129a7e80ad9f95a064eedc6e2e93c06d4f80336500bf2119f05d9da0b",
    "toolName": "cppcheck",
    "warningMessage": "C-style pointer casting",
    "warningSeverity": "style",
    "warningType": "cstyleCast",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintpack\\threadsynchronizer.cpp",
    "lineNumber": "8",
    "columnNumber": "24",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintpack/threadsynchronizer.cpp#L8",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time.",
    "cwe": "398",
    "hashId": "60e78fc16b2512b4d2e20a5b2a08bc5366227a952f212c52fd507f30db27d8e2",
    "toolName": "cppcheck",
    "warningMessage": "Too many #ifdef configurations - cppcheck only checks 12 of 64 configurations. Use --force to check all configurations.",
    "warningSeverity": "information",
    "warningType": "toomanyconfigs",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\CMakeFiles\\2.8.12.2\\CompilerIdCXX\\CMakeCXXCompilerId.cpp",
    "lineNumber": "0",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp#L0",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "%u in format string (no. 3) requires \u0027unsigned int\u0027 but the argument type is \u0027signed int\u0027.",
    "cwe": "686",
    "hashId": "9c9f4ae33fd920c4fb515a6073bd04093e952cd9671a8fd6dc9bbdc9b51f1376",
    "toolName": "cppcheck",
    "warningMessage": "%u in format string (no. 3) requires \u0027unsigned int\u0027 but the argument type is \u0027signed int\u0027.",
    "warningSeverity": "warning",
    "warningType": "invalidPrintfArgType_uint",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\src\\mintsystem\\gcc\\semaphore.c",
    "lineNumber": "29",
    "columnNumber": "5",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/src/mintsystem/gcc/semaphore.c#L29",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/timewaster.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "ff9fcdc8a1e186dd05e6af1aa31a1ba06b8cbcd03c941409ce0938fffd0799c8",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/timewaster.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.main.cpp",
    "lineNumber": "2",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.main.cpp#L2",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintsystem/timer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "df1f58351f2b60efdb4a16c73d33a10bda802e827ce833f5f8857195de804d50",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintsystem/timer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.main.cpp",
    "lineNumber": "3",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.main.cpp#L3",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "979215ca0ed61997b59d6fb657c2d701b3d1d9764cc24c6db181349cc6cdd682",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_add_triangle.cpp",
    "lineNumber": "1",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_add_triangle.cpp#L1",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/timewaster.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "e552e85d3573dbc94653196b29724ca3b67f05e586a0216c63d3ecc02c72a09a",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/timewaster.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_add_triangle.cpp",
    "lineNumber": "2",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_add_triangle.cpp#L2",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/threadsynchronizer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "d2405f47c813a4fe36e5cc401e72ca25704dc8acff3aedb1b4bb0288ad60dde5",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/threadsynchronizer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_add_triangle.cpp",
    "lineNumber": "3",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_add_triangle.cpp#L3",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "914c1e7bb93ec1a77905e7bfa001116e88c4fca544a0e85ef2edc4e5d301dd83",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_bitarray.cpp",
    "lineNumber": "1",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_bitarray.cpp#L1",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/random.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "31922e21326bfa386c7ebed77e09755c2d84ebd61625f88e0cad33dd97bd2e6b",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/random.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_bitarray.cpp",
    "lineNumber": "2",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_bitarray.cpp#L2",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/timewaster.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "0b5c379866a5b016f3e058c4dfdc7c7554d77ccfb13d345b87c4e8100e434dde",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/timewaster.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_bitarray.cpp",
    "lineNumber": "3",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_bitarray.cpp#L3",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/threadsynchronizer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "6fdf0288138a5d9ee016c04a1cd671d25ff577302e1ef88f9f56e514ad60e936",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/threadsynchronizer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_bitarray.cpp",
    "lineNumber": "4",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_bitarray.cpp#L4",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "fc00afa51999b3ce98ccbf75ab95c936877c186b8c4a432b5ac8bfa9b9de0eb9",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_increment.cpp",
    "lineNumber": "1",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_increment.cpp#L1",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/timewaster.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "4d8001a3ef9cdc121e3a4c488e9590cb546e3c6e7181e36e7fc3a5752e66bda6",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/timewaster.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_increment.cpp",
    "lineNumber": "2",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_increment.cpp#L2",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/threadsynchronizer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "12f2972fa8b71dbfb7fe891de20792422a810eb275238eaa89630ac5633e0fc9",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/threadsynchronizer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_increment.cpp",
    "lineNumber": "3",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_increment.cpp#L3",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "cf602c712bda284f22f0d0b847e5390a007d8185c1141c927cb831a345e586f9",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_linkedlist.cpp",
    "lineNumber": "1",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_linkedlist.cpp#L1",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/threadsynchronizer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "ba6606163bbf228723b8d0e270d8194efbd5654b7c6c6e4b9f1586465890102f",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/threadsynchronizer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_linkedlist.cpp",
    "lineNumber": "2",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_linkedlist.cpp#L2",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "22cbabac1f3e6f25ad7c05bc4b591dac488fb3b4e42a900283917bed2e5585d8",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_load_store.cpp",
    "lineNumber": "4",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_load_store.cpp#L4",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/threadsynchronizer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "0c9b19d5b3d6f1510eeb0f0f984c8ea097cf56fe4cdf684b8229683198a3d27f",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/threadsynchronizer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_load_store.cpp",
    "lineNumber": "5",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_load_store.cpp#L5",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "36bdca3ba1de0d521418ad7f33c489547fd3d1f4be5ea16202abcd2c5f09dd70",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_mutex_acq_rel.cpp",
    "lineNumber": "3",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_mutex_acq_rel.cpp#L3",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/timewaster.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "be23a27ce6562cdaf85566181ee2fcc64fbdc258a86f4fee60e4fcb524a17557",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/timewaster.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_mutex_acq_rel.cpp",
    "lineNumber": "4",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_mutex_acq_rel.cpp#L4",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/threadsynchronizer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "3fd575f1c5a512933deaeeb43f883340d44e6dad0bcb1b75c5e87e2c43f12bdb",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/threadsynchronizer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_mutex_acq_rel.cpp",
    "lineNumber": "5",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_mutex_acq_rel.cpp#L5",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected.",
    "cwe": "398",
    "hashId": "7b51a574a166258734416cbbc9fdd0affd52cb826d9d34ac8f5fcf03eb733e15",
    "toolName": "cppcheck",
    "warningMessage": "C-style pointer casting",
    "warningSeverity": "style",
    "warningType": "cstyleCast",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_linkedlist.cpp",
    "lineNumber": "20",
    "columnNumber": "17",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_linkedlist.cpp#L20",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "90ba54fdd0992f884c4f4c45315a0933f07a554ee835b1af7a9022be01f9f8d7",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_storeload.cpp",
    "lineNumber": "3",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_storeload.cpp#L3",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/random.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "781e088fb616291868c6925cde6cf552b396d3e93097ce8bd08cb8fdc237714f",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/random.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_storeload.cpp",
    "lineNumber": "4",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_storeload.cpp#L4",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/threadsynchronizer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "91cd7f9b61d3c2207ca8df2eabf74ab2559daec41348f072ba4beedeb467582d",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/threadsynchronizer.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_storeload.cpp",
    "lineNumber": "5",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_storeload.cpp#L5",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "4f3d56cdd7f8479ca9f2db7483250c3c6efc649bbaf33d68fb6970b8e79c1c7c",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintomic/mintomic.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_return_values.cpp",
    "lineNumber": "1",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_return_values.cpp#L1",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmintpack/random.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "8a76bb1df2954f0dc41bb4627b0114aaf9294a0c266e43f0da3d403ee9b9bdb2",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmintpack/random.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\mintomic\\tests\\template.test_return_values.cpp",
    "lineNumber": "2",
    "columnNumber": "0",
    "commitId": "ed6e75643da0bdd1391e258db386483e00daee82",
    "commitChildId": "cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "commitTitle": "[C] Add initial c port of WriterReaderPhaser.  Add mintomic for cross-platform non-blocking goodness.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/cb5e99a8aa732d49c3e27ea50581e6dcaca00c34",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ed6e75643da0bdd1391e258db386483e00daee82/src/main/c/mintomic/tests/template.test_return_values.cpp#L2",
    "gitDiffText": "diff --git a/src/main/c/mintomic/tests/template.test_storeload.cpp b/src/main/c/mintomic/tests/template.test_storeload.cpp\nnew file mode 100644\nindex 0000000..9a18060\n--- /dev/null\n+++ b/src/main/c/mintomic/tests/template.test_storeload.cpp\n@@ -0,0 +1,53 @@\n+// This test is based on the blog post: http://preshing.com/20120515/memory-reordering-caught-in-the-act\n+\n+#include \u003cmintomic/mintomic.h\u003e\n+#include \u003cmintpack/random.h\u003e\n+#include \u003cmintpack/threadsynchronizer.h\u003e\n+#include \u003cassert.h\u003e\n+\n+\n+#cmakedefine01 TEST_FORCE_FAIL\n+\n+static Random g_random[2];\n+static int X, Y;\n+static int r1, r2;\n+\n+static void threadFunc(int threadNum)\n+{\n+    if (threadNum \u003d\u003d 0)\n+    {\n+        while (g_random[0].generate32() % 8 !\u003d 0) {}  // Random delay\n+        X \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r1 \u003d Y;\n+    }\n+    else\n+    {\n+        while (g_random[1].generate32() % 8 !\u003d 0) {}  // Random delay\n+        Y \u003d 1;\n+#if TEST_FORCE_FAIL\n+        mint_signal_fence_seq_cst();  // Prevent compiler reordering only\n+#else\n+        mint_thread_fence_seq_cst();  // Prevent CPU reordering\n+#endif\n+        r2 \u003d X;\n+    }\n+}\n+\n+bool ${TEST_FUNC}(int numThreads)\n+{\n+    assert(numThreads \u003d\u003d 2);\n+    ThreadSynchronizer threads(2);\n+    for (int i \u003d 0; i \u003c 100000; i++)\n+    {\n+        X \u003d Y \u003d 0;\n+        threads.run(threadFunc);\n+        if (r1 \u003d\u003d 0 \u0026\u0026 r2 \u003d\u003d 0)\n+            return false;\n+    }\n+    return true;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Condition \u0027rc!\u003d0\u0027 is always false",
    "cwe": "570",
    "info": "Condition \u0027rc!\u003d0\u0027 is always false",
    "hashId": "73cdbc520994019fb2c043e6a9f01575fbbc1943ae2e00cc3d98a51006886f69",
    "toolName": "cppcheck",
    "warningMessage": "Condition \u0027rc!\u003d0\u0027 is always false",
    "warningSeverity": "style",
    "warningType": "knownConditionTrueFalse",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\examples\\c\\hdr_histogram_format_example.c",
    "lineNumber": "39",
    "columnNumber": "12",
    "commitId": "e6b5e4517757bca59cc4105308c2bf4c36120e41",
    "commitChildId": "797d41d6f546f8abdc224d5fa35b9925b2eb61d4",
    "commitTitle": "[C] Show error handling in example.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/797d41d6f546f8abdc224d5fa35b9925b2eb61d4",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/e6b5e4517757bca59cc4105308c2bf4c36120e41/src/examples/c/hdr_histogram_format_example.c#L39",
    "gitDiffText": "diff --git a/src/examples/c/hdr_histogram_format_example.c b/src/examples/c/hdr_histogram_format_example.c\nindex 669a75c..737577e 100644\n--- a/src/examples/c/hdr_histogram_format_example.c\n+++ b/src/examples/c/hdr_histogram_format_example.c\n@@ -26,6 +26,19 @@\n     hdr_record_value(raw_histogram, 100000000L);\n     hdr_record_corrected_value(cor_histogram, 100000000L, 10000L);\n \n-    hdr_percentiles_print(raw_histogram, stdout, 5, 1.0, CLASSIC);\n+    int rc \u003d 0;\n+\n+    rc \u003d hdr_percentiles_print(raw_histogram, stdout, 5, 1.0, CLASSIC);\n+    if (rc !\u003d 0)\n+    {\n+        printf(\"Failed to format raw_histogram: %s\\n\", strerror(rc));\n+        return rc;\n+    }\n+\n     hdr_percentiles_print(cor_histogram, stdout, 5, 1.0, CLASSIC);\n+    if (rc !\u003d 0)\n+    {\n+        printf(\"Failed to format cor_histogram: %s\\n\", strerror(rc));\n+        return rc;\n+    }\n }\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Condition \u0027rc!\u003d0\u0027 is always false",
    "cwe": "570",
    "info": "Assuming that condition \u0027rc!\u003d0\u0027 is not redundant",
    "hashId": "73cdbc520994019fb2c043e6a9f01575fbbc1943ae2e00cc3d98a51006886f69",
    "toolName": "cppcheck",
    "warningMessage": "Condition \u0027rc!\u003d0\u0027 is always false",
    "warningSeverity": "style",
    "warningType": "knownConditionTrueFalse",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\examples\\c\\hdr_histogram_format_example.c",
    "lineNumber": "32",
    "columnNumber": "12",
    "commitId": "e6b5e4517757bca59cc4105308c2bf4c36120e41",
    "commitChildId": "797d41d6f546f8abdc224d5fa35b9925b2eb61d4",
    "commitTitle": "[C] Show error handling in example.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/797d41d6f546f8abdc224d5fa35b9925b2eb61d4",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/e6b5e4517757bca59cc4105308c2bf4c36120e41/src/examples/c/hdr_histogram_format_example.c#L32",
    "gitDiffText": "diff --git a/src/examples/c/hdr_histogram_format_example.c b/src/examples/c/hdr_histogram_format_example.c\nindex 669a75c..737577e 100644\n--- a/src/examples/c/hdr_histogram_format_example.c\n+++ b/src/examples/c/hdr_histogram_format_example.c\n@@ -26,6 +26,19 @@\n     hdr_record_value(raw_histogram, 100000000L);\n     hdr_record_corrected_value(cor_histogram, 100000000L, 10000L);\n \n-    hdr_percentiles_print(raw_histogram, stdout, 5, 1.0, CLASSIC);\n+    int rc \u003d 0;\n+\n+    rc \u003d hdr_percentiles_print(raw_histogram, stdout, 5, 1.0, CLASSIC);\n+    if (rc !\u003d 0)\n+    {\n+        printf(\"Failed to format raw_histogram: %s\\n\", strerror(rc));\n+        return rc;\n+    }\n+\n     hdr_percentiles_print(cor_histogram, stdout, 5, 1.0, CLASSIC);\n+    if (rc !\u003d 0)\n+    {\n+        printf(\"Failed to format cor_histogram: %s\\n\", strerror(rc));\n+        return rc;\n+    }\n }\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Local variable \u0027value_from_index\u0027 shadows outer function",
    "cwe": "398",
    "info": "Shadow variable",
    "hashId": "ca892229868ff09dd8d2d0a3bf16e689d76f5beaa4ca80c8da5c06e89d514d61",
    "toolName": "cppcheck",
    "warningMessage": "Local variable \u0027value_from_index\u0027 shadows outer function",
    "warningSeverity": "style",
    "warningType": "shadowFunction",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\hdr_histogram.c",
    "lineNumber": "352",
    "columnNumber": "21",
    "commitId": "55b47752eaff846d3ed02ddcb6567c1c959f13dd",
    "commitChildId": "66032e1f328989ee7272bdaeaa6fbd53538a5534",
    "commitTitle": "[C] Use highest equivalent value in hdr_value_at_percentile.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/66032e1f328989ee7272bdaeaa6fbd53538a5534",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/55b47752eaff846d3ed02ddcb6567c1c959f13dd/src/main/c/hdr_histogram.c#L352",
    "gitDiffText": "diff --git a/src/main/c/hdr_histogram.c b/src/main/c/hdr_histogram.c\nindex b950b53..87e6542 100644\n--- a/src/main/c/hdr_histogram.c\n+++ b/src/main/c/hdr_histogram.c\n@@ -338,7 +338,8 @@\n     hdr_iter_init(\u0026iter, h);\n \n     double requested_percentile \u003d percentile \u003c 100.0 ? percentile : 100.0;\n-    int64_t count_at_percentile \u003d (int64_t) (((requested_percentile / 100) * h-\u003etotal_count) + 0.5);\n+    int64_t count_at_percentile \u003d\n+        (int64_t) (((requested_percentile / 100) * h-\u003etotal_count) + 0.5);\n     count_at_percentile \u003d count_at_percentile \u003e 1 ? count_at_percentile : 1;\n     int64_t total \u003d 0;\n \n@@ -348,7 +349,8 @@\n \n         if (total \u003e\u003d count_at_percentile)\n         {\n-            return iter.value_from_index;\n+            int64_t value_from_index \u003d iter.value_from_index;\n+            return highest_equivalent_value(h, value_from_index);\n         }\n     }\n \n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Local variable \u0027value_from_index\u0027 shadows outer function",
    "cwe": "398",
    "info": "Shadowed declaration",
    "hashId": "ca892229868ff09dd8d2d0a3bf16e689d76f5beaa4ca80c8da5c06e89d514d61",
    "toolName": "cppcheck",
    "warningMessage": "Local variable \u0027value_from_index\u0027 shadows outer function",
    "warningSeverity": "style",
    "warningType": "shadowFunction",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\hdr_histogram.c",
    "lineNumber": "75",
    "columnNumber": "16",
    "commitId": "55b47752eaff846d3ed02ddcb6567c1c959f13dd",
    "commitChildId": "66032e1f328989ee7272bdaeaa6fbd53538a5534",
    "commitTitle": "[C] Use highest equivalent value in hdr_value_at_percentile.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/66032e1f328989ee7272bdaeaa6fbd53538a5534",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/55b47752eaff846d3ed02ddcb6567c1c959f13dd/src/main/c/hdr_histogram.c#L75",
    "gitDiffText": "diff --git a/src/main/c/hdr_histogram.c b/src/main/c/hdr_histogram.c\nindex b950b53..87e6542 100644\n--- a/src/main/c/hdr_histogram.c\n+++ b/src/main/c/hdr_histogram.c\n@@ -338,7 +338,8 @@\n     hdr_iter_init(\u0026iter, h);\n \n     double requested_percentile \u003d percentile \u003c 100.0 ? percentile : 100.0;\n-    int64_t count_at_percentile \u003d (int64_t) (((requested_percentile / 100) * h-\u003etotal_count) + 0.5);\n+    int64_t count_at_percentile \u003d\n+        (int64_t) (((requested_percentile / 100) * h-\u003etotal_count) + 0.5);\n     count_at_percentile \u003d count_at_percentile \u003e 1 ? count_at_percentile : 1;\n     int64_t total \u003d 0;\n \n@@ -348,7 +349,8 @@\n \n         if (total \u003e\u003d count_at_percentile)\n         {\n-            return iter.value_from_index;\n+            int64_t value_from_index \u003d iter.value_from_index;\n+            return highest_equivalent_value(h, value_from_index);\n         }\n     }\n \n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "The scope of the variable \u0027a_str\u0027 can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for \u0027i\u0027 can be reduced:\\012void f(int x)\\012{\\012    int i \u003d 0;\\012    if (x) {\\012        // it\u0027s safe to move \u0027int i \u003d 0;\u0027 here\\012        for (int n \u003d 0; n \u003c 10; ++n) {\\012            // it is possible but not safe to move \u0027int i \u003d 0;\u0027 here\\012            do_something(\u0026i);\\012        }\\012    }\\012}\\012When you see this message it is always safe to reduce the variable scope 1 level.",
    "cwe": "398",
    "hashId": "bd562a066f2d6e2bdf1d1dbf1874c5e37a291d363428010cc5a93866f8d4d6cc",
    "toolName": "cppcheck",
    "warningMessage": "The scope of the variable \u0027a_str\u0027 can be reduced.",
    "warningSeverity": "style",
    "warningType": "variableScope",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\test\\c\\hdr_histogram_log_test.c",
    "lineNumber": "51",
    "columnNumber": "10",
    "commitId": "c8414d64c7287bd1f8d2aa40aee1e84b4641d704",
    "commitChildId": "f062a81688c0d6a5c64a5e98d71e436d3640c540",
    "commitTitle": "[C] Fill in timestamps from log file on each read.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/f062a81688c0d6a5c64a5e98d71e436d3640c540",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/c8414d64c7287bd1f8d2aa40aee1e84b4641d704/src/test/c/hdr_histogram_log_test.c#L51",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_log_test.c b/src/test/c/hdr_histogram_log_test.c\nindex 704014d..7f6b71d 100644\n--- a/src/test/c/hdr_histogram_log_test.c\n+++ b/src/test/c/hdr_histogram_log_test.c\n@@ -30,17 +30,6 @@\n     return false;\n }\n \n-static bool compare_long(long a, long b)\n-{\n-    if (a \u003d\u003d b)\n-    {\n-        return true;\n-    }\n-\n-    printf(\"%ld !\u003d %ld\\n\", a, b);\n-    return false;\n-}\n-\n static bool compare_int64_t(int64_t a, int64_t b)\n {\n     if (a \u003d\u003d b)\n@@ -52,17 +41,37 @@\n     return false;\n }\n \n-static time_t compare_time_t(time_t a, time_t b)\n+static long ns_to_ms(long ns)\n {\n-    if (a \u003d\u003d b)\n+    return (ns / 1000000) * 1000000;\n+}\n+\n+static bool compare_timespec(struct timespec* a, struct timespec* b)\n+{\n+    char a_str[128];\n+    char b_str[128];\n+\n+    long a_tv_msec \u003d ns_to_ms(a-\u003etv_nsec);\n+    long b_tv_msec \u003d ns_to_ms(b-\u003etv_nsec);\n+\n+    if (a-\u003etv_sec \u003d\u003d a-\u003etv_sec \u0026\u0026 a_tv_msec \u003d\u003d b_tv_msec)\n     {\n         return true;\n     }\n \n-    char a_str[128];\n-    char b_str[128];\n+    if (a-\u003etv_sec !\u003d b-\u003etv_sec)\n+    {\n+        printf(\n+            \"tv_sec: %s !\u003d %s\\n\",\n+            ctime_r(\u0026a-\u003etv_sec, a_str),\n+            ctime_r(\u0026b-\u003etv_sec, b_str));\n+    }\n \n-    printf(\"%s !\u003d %s\\n\", ctime_r(\u0026a, a_str), ctime_r(\u0026b, b_str));\n+    if (a_tv_msec \u003d\u003d b_tv_msec)\n+    {\n+        printf(\"%ld !\u003d %ld\\n\", a-\u003etv_nsec, b-\u003etv_nsec);\n+    }\n+\n     return false;\n }\n \n@@ -403,14 +412,23 @@\n     mu_assert(\"Failed header read\", validate_return_code(rc));\n     mu_assert(\"Incorrect major version\", compare_int(reader.major_version, 1));\n     mu_assert(\"Incorrect minor version\", compare_int(reader.minor_version, 1));\n-    mu_assert(\"Incorrect timestamp (sec)\",\n-        compare_time_t(reader.start_timestamp.tv_sec, timestamp.tv_sec));\n-    mu_assert(\"Incorrect timestamp (nsec)\",\n-        compare_long(reader.start_timestamp.tv_nsec, expected_nsec));\n+    mu_assert(\n+        \"Incorrect start timestamp\",\n+        compare_timespec(\u0026reader.start_timestamp, \u0026timestamp));\n \n-    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026read_cor_histogram);\n+    struct timespec actual_timestamp;\n+    struct timespec actual_interval;\n+\n+    rc \u003d hdr_log_read(\n+        \u0026reader, log_file, \u0026read_cor_histogram,\n+        \u0026actual_timestamp, \u0026actual_interval);\n     mu_assert(\"Failed corrected read\", validate_return_code(rc));\n-    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026read_raw_histogram);\n+    mu_assert(\n+        \"Incorrect first timestamp\", compare_timespec(\u0026actual_timestamp, \u0026timestamp));\n+    mu_assert(\n+        \"Incorrect first interval\", compare_timespec(\u0026actual_interval, \u0026interval));\n+\n+    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026read_raw_histogram, NULL, NULL);\n     mu_assert(\"Failed raw read\", validate_return_code(rc));\n \n     mu_assert(\n@@ -421,7 +439,7 @@\n         \"Histograms do not match\",\n         compare_histogram(raw_histogram, read_raw_histogram));\n \n-    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026read_cor_histogram);\n+    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026read_cor_histogram, NULL, NULL);\n     mu_assert(\"No EOF at end of file\", rc \u003d\u003d EOF);\n \n     fclose(log_file);\n@@ -461,9 +479,9 @@\n \n     rc \u003d hdr_log_read_header(\u0026reader, log_file);\n     mu_assert(\"Failed header read\", validate_return_code(rc));\n-    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026histogram);\n+    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026histogram, NULL, NULL);\n     mu_assert(\"Failed corrected read\", validate_return_code(rc));\n-    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026histogram);\n+    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026histogram, NULL, NULL);\n     mu_assert(\"Failed raw read\", validate_return_code(rc));\n \n     struct hdr_recorded_iter iter;\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "The scope of the variable \u0027b_str\u0027 can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for \u0027i\u0027 can be reduced:\\012void f(int x)\\012{\\012    int i \u003d 0;\\012    if (x) {\\012        // it\u0027s safe to move \u0027int i \u003d 0;\u0027 here\\012        for (int n \u003d 0; n \u003c 10; ++n) {\\012            // it is possible but not safe to move \u0027int i \u003d 0;\u0027 here\\012            do_something(\u0026i);\\012        }\\012    }\\012}\\012When you see this message it is always safe to reduce the variable scope 1 level.",
    "cwe": "398",
    "hashId": "dcaa8613742fb783786e34eec12619043dead017f95dcee01268dd80910c26c3",
    "toolName": "cppcheck",
    "warningMessage": "The scope of the variable \u0027b_str\u0027 can be reduced.",
    "warningSeverity": "style",
    "warningType": "variableScope",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\test\\c\\hdr_histogram_log_test.c",
    "lineNumber": "52",
    "columnNumber": "10",
    "commitId": "c8414d64c7287bd1f8d2aa40aee1e84b4641d704",
    "commitChildId": "f062a81688c0d6a5c64a5e98d71e436d3640c540",
    "commitTitle": "[C] Fill in timestamps from log file on each read.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/f062a81688c0d6a5c64a5e98d71e436d3640c540",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/c8414d64c7287bd1f8d2aa40aee1e84b4641d704/src/test/c/hdr_histogram_log_test.c#L52",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_log_test.c b/src/test/c/hdr_histogram_log_test.c\nindex 704014d..7f6b71d 100644\n--- a/src/test/c/hdr_histogram_log_test.c\n+++ b/src/test/c/hdr_histogram_log_test.c\n@@ -30,17 +30,6 @@\n     return false;\n }\n \n-static bool compare_long(long a, long b)\n-{\n-    if (a \u003d\u003d b)\n-    {\n-        return true;\n-    }\n-\n-    printf(\"%ld !\u003d %ld\\n\", a, b);\n-    return false;\n-}\n-\n static bool compare_int64_t(int64_t a, int64_t b)\n {\n     if (a \u003d\u003d b)\n@@ -52,17 +41,37 @@\n     return false;\n }\n \n-static time_t compare_time_t(time_t a, time_t b)\n+static long ns_to_ms(long ns)\n {\n-    if (a \u003d\u003d b)\n+    return (ns / 1000000) * 1000000;\n+}\n+\n+static bool compare_timespec(struct timespec* a, struct timespec* b)\n+{\n+    char a_str[128];\n+    char b_str[128];\n+\n+    long a_tv_msec \u003d ns_to_ms(a-\u003etv_nsec);\n+    long b_tv_msec \u003d ns_to_ms(b-\u003etv_nsec);\n+\n+    if (a-\u003etv_sec \u003d\u003d a-\u003etv_sec \u0026\u0026 a_tv_msec \u003d\u003d b_tv_msec)\n     {\n         return true;\n     }\n \n-    char a_str[128];\n-    char b_str[128];\n+    if (a-\u003etv_sec !\u003d b-\u003etv_sec)\n+    {\n+        printf(\n+            \"tv_sec: %s !\u003d %s\\n\",\n+            ctime_r(\u0026a-\u003etv_sec, a_str),\n+            ctime_r(\u0026b-\u003etv_sec, b_str));\n+    }\n \n-    printf(\"%s !\u003d %s\\n\", ctime_r(\u0026a, a_str), ctime_r(\u0026b, b_str));\n+    if (a_tv_msec \u003d\u003d b_tv_msec)\n+    {\n+        printf(\"%ld !\u003d %ld\\n\", a-\u003etv_nsec, b-\u003etv_nsec);\n+    }\n+\n     return false;\n }\n \n@@ -403,14 +412,23 @@\n     mu_assert(\"Failed header read\", validate_return_code(rc));\n     mu_assert(\"Incorrect major version\", compare_int(reader.major_version, 1));\n     mu_assert(\"Incorrect minor version\", compare_int(reader.minor_version, 1));\n-    mu_assert(\"Incorrect timestamp (sec)\",\n-        compare_time_t(reader.start_timestamp.tv_sec, timestamp.tv_sec));\n-    mu_assert(\"Incorrect timestamp (nsec)\",\n-        compare_long(reader.start_timestamp.tv_nsec, expected_nsec));\n+    mu_assert(\n+        \"Incorrect start timestamp\",\n+        compare_timespec(\u0026reader.start_timestamp, \u0026timestamp));\n \n-    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026read_cor_histogram);\n+    struct timespec actual_timestamp;\n+    struct timespec actual_interval;\n+\n+    rc \u003d hdr_log_read(\n+        \u0026reader, log_file, \u0026read_cor_histogram,\n+        \u0026actual_timestamp, \u0026actual_interval);\n     mu_assert(\"Failed corrected read\", validate_return_code(rc));\n-    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026read_raw_histogram);\n+    mu_assert(\n+        \"Incorrect first timestamp\", compare_timespec(\u0026actual_timestamp, \u0026timestamp));\n+    mu_assert(\n+        \"Incorrect first interval\", compare_timespec(\u0026actual_interval, \u0026interval));\n+\n+    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026read_raw_histogram, NULL, NULL);\n     mu_assert(\"Failed raw read\", validate_return_code(rc));\n \n     mu_assert(\n@@ -421,7 +439,7 @@\n         \"Histograms do not match\",\n         compare_histogram(raw_histogram, read_raw_histogram));\n \n-    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026read_cor_histogram);\n+    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026read_cor_histogram, NULL, NULL);\n     mu_assert(\"No EOF at end of file\", rc \u003d\u003d EOF);\n \n     fclose(log_file);\n@@ -461,9 +479,9 @@\n \n     rc \u003d hdr_log_read_header(\u0026reader, log_file);\n     mu_assert(\"Failed header read\", validate_return_code(rc));\n-    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026histogram);\n+    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026histogram, NULL, NULL);\n     mu_assert(\"Failed corrected read\", validate_return_code(rc));\n-    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026histogram);\n+    rc \u003d hdr_log_read(\u0026reader, log_file, \u0026histogram, NULL, NULL);\n     mu_assert(\"Failed raw read\", validate_return_code(rc));\n \n     struct hdr_recorded_iter iter;\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cinttypes.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "3dbdae01b4de9fa97ccca60cf82f5ae286dd874bc96c61e0bb6c03db687b5a3f",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cinttypes.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\hdr_histogram.c",
    "lineNumber": "17",
    "columnNumber": "0",
    "commitId": "0e2fcd6ee78f48adf4956f8d59a606661246d625",
    "commitChildId": "da70fab4c3169a5ce08ea22951755a8e77f2a6a1",
    "commitTitle": "[C] Use correct format options for uint64_t.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/da70fab4c3169a5ce08ea22951755a8e77f2a6a1",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/0e2fcd6ee78f48adf4956f8d59a606661246d625/src/main/c/hdr_histogram.c#L17",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_test.c b/src/test/c/hdr_histogram_test.c\nindex 7a853e1..ed97e74 100644\n--- a/src/test/c/hdr_histogram_test.c\n+++ b/src/test/c/hdr_histogram_test.c\n@@ -10,6 +10,7 @@\n #include \u003cmath.h\u003e\n #include \u003cstring.h\u003e\n #include \u003cerrno.h\u003e\n+#include \u003cinttypes.h\u003e\n \n #include \u003cstdio.h\u003e\n #include \u003chdr_histogram.h\u003e\n@@ -34,7 +35,7 @@\n         return true;\n     }\n \n-    printf(\"[compare_int64] %ld \u003d\u003d %ld \u003d\u003d false\\n\", a, b);\n+    printf(\"[compare_int64] %\" PRIu64 \" \u003d\u003d %\" PRIu64 \" \u003d\u003d false\\n\", a, b);\n     return false;\n }\n \n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cinttypes.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "c6395a55d004546f806faf7360649252db4c4f8a775c75b627c454ff8f2946a8",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cinttypes.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\test\\c\\hdr_histogram_test.c",
    "lineNumber": "13",
    "columnNumber": "0",
    "commitId": "0e2fcd6ee78f48adf4956f8d59a606661246d625",
    "commitChildId": "da70fab4c3169a5ce08ea22951755a8e77f2a6a1",
    "commitTitle": "[C] Use correct format options for uint64_t.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/da70fab4c3169a5ce08ea22951755a8e77f2a6a1",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/0e2fcd6ee78f48adf4956f8d59a606661246d625/src/test/c/hdr_histogram_test.c#L13",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_test.c b/src/test/c/hdr_histogram_test.c\nindex 7a853e1..ed97e74 100644\n--- a/src/test/c/hdr_histogram_test.c\n+++ b/src/test/c/hdr_histogram_test.c\n@@ -10,6 +10,7 @@\n #include \u003cmath.h\u003e\n #include \u003cstring.h\u003e\n #include \u003cerrno.h\u003e\n+#include \u003cinttypes.h\u003e\n \n #include \u003cstdio.h\u003e\n #include \u003chdr_histogram.h\u003e\n@@ -34,7 +35,7 @@\n         return true;\n     }\n \n-    printf(\"[compare_int64] %ld \u003d\u003d %ld \u003d\u003d false\\n\", a, b);\n+    printf(\"[compare_int64] %\" PRIu64 \" \u003d\u003d %\" PRIu64 \" \u003d\u003d false\\n\", a, b);\n     return false;\n }\n \n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cctype.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "e8e70f120f946422548b3aa59b53ef9f609e243cf3c48e0637f45a4c9fe09815",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cctype.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\hdr_histogram_log.c",
    "lineNumber": "15",
    "columnNumber": "0",
    "commitId": "f8ef40841d15978643266d5af629efaa1296f637",
    "commitChildId": "70586bf869c28f81b4856fd93274db0e686e0ccb",
    "commitTitle": "[C] Add more partial implementation for histogram logging.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/70586bf869c28f81b4856fd93274db0e686e0ccb",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/f8ef40841d15978643266d5af629efaa1296f637/src/main/c/hdr_histogram_log.c#L15",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_log_test.c b/src/test/c/hdr_histogram_log_test.c\nindex 492d49b..2951b3c 100644\n--- a/src/test/c/hdr_histogram_log_test.c\n+++ b/src/test/c/hdr_histogram_log_test.c\n@@ -216,6 +216,16 @@\n     return 0;\n }\n \n+static char* test_parse_log()\n+{\n+    struct hdr_histogram* h;\n+    FILE* log_file \u003d fopen(\"src/test/resources/hiccup.140623.1028.10646.hlog\", \"r\");\n+\n+    int result \u003d hdr_parse_log(log_file, \u0026h);\n+\n+    return 0;\n+}\n+\n \n static struct mu_result all_tests()\n {\n@@ -226,6 +236,7 @@\n     mu_run_test(test_encode_to_base64);\n     mu_run_test(test_base64_decode_block);\n     mu_run_test(test_decode_from_base64);\n+    mu_run_test(test_parse_log);\n \n     mu_ok;\n }\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmach/clock.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "e532f866e54ecaffdddefe2a2d1c03a05d7c6b6ccab84ba284c656f0412b74a5",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmach/clock.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\test\\c\\hdr_histogram_perf.c",
    "lineNumber": "13",
    "columnNumber": "0",
    "commitId": "f6fbe73b6096ed2e775045c3231331825c620161",
    "commitChildId": "4180f3c2b3804d3c175a6bf1895ab892929aeb31",
    "commitTitle": "[C] Return MacOS build to working order - use clock_get_time as an alternative to clock_gettime.  No librt on Mac.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/4180f3c2b3804d3c175a6bf1895ab892929aeb31",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/f6fbe73b6096ed2e775045c3231331825c620161/src/test/c/hdr_histogram_perf.c#L13",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_perf.c b/src/test/c/hdr_histogram_perf.c\nindex 0490b10..acc9167 100644\n--- a/src/test/c/hdr_histogram_perf.c\n+++ b/src/test/c/hdr_histogram_perf.c\n@@ -5,18 +5,49 @@\n \n #include \u003cstdio.h\u003e\n #include \u003chdr_histogram.h\u003e\n-#include \u003ctime.h\u003e\n #include \u003clocale.h\u003e\n+#include \u003ctime.h\u003e\n+\n+\n+#ifdef __APPLE__\n+#include \u003cmach/clock.h\u003e\n+#include \u003cmach/mach.h\u003e\n+\n+void hdr_gettime(struct timespec* ts)\n+{\n+    clock_serv_t cclock;\n+    mach_timespec_t mts;\n+    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, \u0026cclock);\n+    clock_get_time(cclock, \u0026mts);\n+    mach_port_deallocate(mach_task_self(), cclock);\n+    ts-\u003etv_sec \u003d mts.tv_sec;\n+    ts-\u003etv_nsec \u003d mts.tv_nsec;\n+}\n+\n+\n+#elif __LINUX__\n+\n+void hdr_gettime(struct timespec* t)\n+{\n+    clock_gettime(CLOCK_MONOTONIC_RAW, t);\n+}\n+\n+#else\n+\n+#warning \"Platform not supported\\n\"\n+\n+#endif\n+\n \n struct timespec diff(struct timespec start, struct timespec end)\n {\n     struct timespec temp;\n-    if ((end.tv_nsec-start.tv_nsec) \u003c 0) \n+    if ((end.tv_nsec-start.tv_nsec) \u003c 0)\n     {\n         temp.tv_sec \u003d end.tv_sec - start.tv_sec - 1;\n         temp.tv_nsec \u003d 1000000000 + end.tv_nsec-start.tv_nsec;\n     }\n-    else \n+    else\n     {\n         temp.tv_sec \u003d end.tv_sec - start.tv_sec;\n         temp.tv_nsec \u003d end.tv_nsec - start.tv_nsec;\n@@ -42,12 +73,12 @@\n \n     for (int i \u003d 0; i \u003c 100; i++)\n     {\n-        clock_gettime(CLOCK_MONOTONIC_RAW, \u0026t0);\n+        hdr_gettime(\u0026t0);\n         for (int64_t j \u003d 1; j \u003c iterations; j++)\n         {\n             hdr_record_value(histogram, j);\n         }\n-        clock_gettime(CLOCK_MONOTONIC_RAW, \u0026t1);\n+        hdr_gettime(\u0026t1);\n \n \n         struct timespec taken \u003d diff(t0, t1);\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cmach/mach.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "f6c1cb029908be6a2983d66d964ca989ee0a2b5bb3b9d1b4a1fb1fd571f00194",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cmach/mach.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\test\\c\\hdr_histogram_perf.c",
    "lineNumber": "14",
    "columnNumber": "0",
    "commitId": "f6fbe73b6096ed2e775045c3231331825c620161",
    "commitChildId": "4180f3c2b3804d3c175a6bf1895ab892929aeb31",
    "commitTitle": "[C] Return MacOS build to working order - use clock_get_time as an alternative to clock_gettime.  No librt on Mac.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/4180f3c2b3804d3c175a6bf1895ab892929aeb31",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/f6fbe73b6096ed2e775045c3231331825c620161/src/test/c/hdr_histogram_perf.c#L14",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_perf.c b/src/test/c/hdr_histogram_perf.c\nindex 0490b10..acc9167 100644\n--- a/src/test/c/hdr_histogram_perf.c\n+++ b/src/test/c/hdr_histogram_perf.c\n@@ -5,18 +5,49 @@\n \n #include \u003cstdio.h\u003e\n #include \u003chdr_histogram.h\u003e\n-#include \u003ctime.h\u003e\n #include \u003clocale.h\u003e\n+#include \u003ctime.h\u003e\n+\n+\n+#ifdef __APPLE__\n+#include \u003cmach/clock.h\u003e\n+#include \u003cmach/mach.h\u003e\n+\n+void hdr_gettime(struct timespec* ts)\n+{\n+    clock_serv_t cclock;\n+    mach_timespec_t mts;\n+    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, \u0026cclock);\n+    clock_get_time(cclock, \u0026mts);\n+    mach_port_deallocate(mach_task_self(), cclock);\n+    ts-\u003etv_sec \u003d mts.tv_sec;\n+    ts-\u003etv_nsec \u003d mts.tv_nsec;\n+}\n+\n+\n+#elif __LINUX__\n+\n+void hdr_gettime(struct timespec* t)\n+{\n+    clock_gettime(CLOCK_MONOTONIC_RAW, t);\n+}\n+\n+#else\n+\n+#warning \"Platform not supported\\n\"\n+\n+#endif\n+\n \n struct timespec diff(struct timespec start, struct timespec end)\n {\n     struct timespec temp;\n-    if ((end.tv_nsec-start.tv_nsec) \u003c 0) \n+    if ((end.tv_nsec-start.tv_nsec) \u003c 0)\n     {\n         temp.tv_sec \u003d end.tv_sec - start.tv_sec - 1;\n         temp.tv_nsec \u003d 1000000000 + end.tv_nsec-start.tv_nsec;\n     }\n-    else \n+    else\n     {\n         temp.tv_sec \u003d end.tv_sec - start.tv_sec;\n         temp.tv_nsec \u003d end.tv_nsec - start.tv_nsec;\n@@ -42,12 +73,12 @@\n \n     for (int i \u003d 0; i \u003c 100; i++)\n     {\n-        clock_gettime(CLOCK_MONOTONIC_RAW, \u0026t0);\n+        hdr_gettime(\u0026t0);\n         for (int64_t j \u003d 1; j \u003c iterations; j++)\n         {\n             hdr_record_value(histogram, j);\n         }\n-        clock_gettime(CLOCK_MONOTONIC_RAW, \u0026t1);\n+        hdr_gettime(\u0026t1);\n \n \n         struct timespec taken \u003d diff(t0, t1);\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003clibkern/OSByteOrder.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "a6e45cc8d0b8c655789bfc39e79e261983dc73bc786bb4869a73b3aa963d92d3",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003clibkern/OSByteOrder.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\hdr_histogram_log.c",
    "lineNumber": "20",
    "columnNumber": "0",
    "commitId": "f6fbe73b6096ed2e775045c3231331825c620161",
    "commitChildId": "4180f3c2b3804d3c175a6bf1895ab892929aeb31",
    "commitTitle": "[C] Return MacOS build to working order - use clock_get_time as an alternative to clock_gettime.  No librt on Mac.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/4180f3c2b3804d3c175a6bf1895ab892929aeb31",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/f6fbe73b6096ed2e775045c3231331825c620161/src/main/c/hdr_histogram_log.c#L20",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_perf.c b/src/test/c/hdr_histogram_perf.c\nindex 0490b10..acc9167 100644\n--- a/src/test/c/hdr_histogram_perf.c\n+++ b/src/test/c/hdr_histogram_perf.c\n@@ -5,18 +5,49 @@\n \n #include \u003cstdio.h\u003e\n #include \u003chdr_histogram.h\u003e\n-#include \u003ctime.h\u003e\n #include \u003clocale.h\u003e\n+#include \u003ctime.h\u003e\n+\n+\n+#ifdef __APPLE__\n+#include \u003cmach/clock.h\u003e\n+#include \u003cmach/mach.h\u003e\n+\n+void hdr_gettime(struct timespec* ts)\n+{\n+    clock_serv_t cclock;\n+    mach_timespec_t mts;\n+    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, \u0026cclock);\n+    clock_get_time(cclock, \u0026mts);\n+    mach_port_deallocate(mach_task_self(), cclock);\n+    ts-\u003etv_sec \u003d mts.tv_sec;\n+    ts-\u003etv_nsec \u003d mts.tv_nsec;\n+}\n+\n+\n+#elif __LINUX__\n+\n+void hdr_gettime(struct timespec* t)\n+{\n+    clock_gettime(CLOCK_MONOTONIC_RAW, t);\n+}\n+\n+#else\n+\n+#warning \"Platform not supported\\n\"\n+\n+#endif\n+\n \n struct timespec diff(struct timespec start, struct timespec end)\n {\n     struct timespec temp;\n-    if ((end.tv_nsec-start.tv_nsec) \u003c 0) \n+    if ((end.tv_nsec-start.tv_nsec) \u003c 0)\n     {\n         temp.tv_sec \u003d end.tv_sec - start.tv_sec - 1;\n         temp.tv_nsec \u003d 1000000000 + end.tv_nsec-start.tv_nsec;\n     }\n-    else \n+    else\n     {\n         temp.tv_sec \u003d end.tv_sec - start.tv_sec;\n         temp.tv_nsec \u003d end.tv_nsec - start.tv_nsec;\n@@ -42,12 +73,12 @@\n \n     for (int i \u003d 0; i \u003c 100; i++)\n     {\n-        clock_gettime(CLOCK_MONOTONIC_RAW, \u0026t0);\n+        hdr_gettime(\u0026t0);\n         for (int64_t j \u003d 1; j \u003c iterations; j++)\n         {\n             hdr_record_value(histogram, j);\n         }\n-        clock_gettime(CLOCK_MONOTONIC_RAW, \u0026t1);\n+        hdr_gettime(\u0026t1);\n \n \n         struct timespec taken \u003d diff(t0, t1);\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003chdr_histogram_log.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "346d61b039466e0569248d5c8afc09cfcbd795c06df4e482f136102f8423a41c",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003chdr_histogram_log.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\test\\c\\hdr_histogram_log_test.c",
    "lineNumber": "16",
    "columnNumber": "0",
    "commitId": "6a3485d789a041645ccc2acdd846ac72693a1928",
    "commitChildId": "f6fbe73b6096ed2e775045c3231331825c620161",
    "commitTitle": "[C] Create hdr_histogram_log.{c,h} to handle implemenation for encoding/decoding operations.  Prevents dependency on zlib for users that don\u0027t want logging/encoding.  Separate tests accordingly.",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/f6fbe73b6096ed2e775045c3231331825c620161",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/6a3485d789a041645ccc2acdd846ac72693a1928/src/test/c/hdr_histogram_log_test.c#L16",
    "gitDiffText": "diff --git a/src/test/c/minunit.h b/src/test/c/minunit.h\nindex a482573..052846d 100644\n--- a/src/test/c/minunit.h\n+++ b/src/test/c/minunit.h\n@@ -35,4 +35,4 @@\n         return r;           \\\n     } while (0)\n \n- extern int tests_run;\n+extern int tests_run;\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003czlib.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "e084648e43b1f6a9b91ddfa9f0c2a1f37e9b9ca57d53f1595b742a4cfe7b9caf",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003czlib.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\main\\c\\hdr_histogram.c",
    "lineNumber": "16",
    "columnNumber": "0",
    "commitId": "af87b2eb297dc96c040e17e1d0b02e5204017983",
    "commitChildId": "2a1e481d3033974aa30599b62164b2e4f2ffe516",
    "commitTitle": "[C] Add basic compressed encoding",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/2a1e481d3033974aa30599b62164b2e4f2ffe516",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/af87b2eb297dc96c040e17e1d0b02e5204017983/src/main/c/hdr_histogram.c#L16",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_test.c b/src/test/c/hdr_histogram_test.c\nindex 71e77f5..e119e75 100644\n--- a/src/test/c/hdr_histogram_test.c\n+++ b/src/test/c/hdr_histogram_test.c\n@@ -328,24 +328,24 @@\n {\n     load_histograms();\n \n-    size_t raw_histogram_size \u003d hdr_get_memory_size(raw_histogram);\n+    size_t raw_histogram_size \u003d hdr_get_memory_size(cor_histogram);\n \n-    char* buffer \u003d (char*) malloc(hdr_get_memory_size(raw_histogram));\n+    uint8_t* buffer \u003d (uint8_t*) malloc(hdr_get_memory_size(cor_histogram));\n \n-    size_t encode_result \u003d hdr_encode(raw_histogram, buffer, 0, raw_histogram_size);\n+    size_t encode_result \u003d hdr_encode(cor_histogram, buffer, raw_histogram_size);\n \n     mu_assert(\"Did not encode\", encode_result !\u003d 0);\n     mu_assert(\"Incorrect size\", encode_result \u003c\u003d raw_histogram_size);\n \n     struct hdr_histogram* loaded_histogram \u003d NULL;\n-    hdr_decode(buffer, 0, raw_histogram_size, \u0026loaded_histogram);\n+    hdr_decode(buffer, raw_histogram_size, \u0026loaded_histogram);\n \n-    int compare_result \u003d memcmp(raw_histogram, loaded_histogram, raw_histogram_size);\n+    int compare_result \u003d memcmp(cor_histogram, loaded_histogram, raw_histogram_size);\n \n     if (compare_result !\u003d 0)\n     {\n-        char* a \u003d (char*) raw_histogram;\n-        char* b \u003d (char*) loaded_histogram;\n+        uint8_t* a \u003d (uint8_t*) cor_histogram;\n+        uint8_t* b \u003d (uint8_t*) loaded_histogram;\n         for (int i \u003d 0; i \u003c raw_histogram_size; i++)\n         {\n             if (a[i] !\u003d b[i])\n@@ -360,28 +360,35 @@\n     return 0;\n }\n \n-// static char* test_encode_and_decode_compressed()\n-// {\n-//     load_histograms();\n+static char* test_encode_and_decode_compressed()\n+{\n+    load_histograms();\n \n-//     size_t raw_histogram_size \u003d hdr_get_memory_size(raw_histogram);\n+    size_t raw_histogram_size \u003d hdr_get_memory_size(raw_histogram);\n \n-//     char* buffer \u003d (char*) malloc(hdr_get_memory_size(raw_histogram));\n+    uint8_t* buffer \u003d (uint8_t*) malloc(hdr_get_memory_size(raw_histogram));\n \n-//     size_t encode_result \u003d hdr_encode_compressed(raw_histogram, buffer, 0, raw_histogram_size);\n+    size_t encode_result \u003d hdr_encode_compressed(raw_histogram, buffer, raw_histogram_size);\n \n-//     mu_assert(\"Did not encode\", encode_result !\u003d 0);\n-//     mu_assert(\"Incorrect size\", encode_result \u003c\u003d raw_histogram_size);\n+    mu_assert(\"Did not encode\", encode_result !\u003d 0);\n+    mu_assert(\"Incorrect size\", encode_result \u003c\u003d raw_histogram_size);\n \n-//     struct hdr_histogram* loaded_histogram;\n-//     hdr_decode(buffer, 0, raw_histogram_size, \u0026loaded_histogram);\n+    struct hdr_histogram* loaded_histogram \u003d NULL;\n+    int decode_result \u003d hdr_decode_compressed(buffer, encode_result, \u0026loaded_histogram);\n \n-//     int compare_result \u003d memcmp(raw_histogram, loaded_histogram, raw_histogram_size);\n+    if (decode_result !\u003d 0)\n+    {\n+        printf(\"%s\\n\", hdr_strerror(decode_result));\n+    }\n+    mu_assert(\"Did not decode\", decode_result \u003d\u003d 0);\n \n-//     mu_assert(\"Comparison did not match\", compare_result \u003d\u003d 0);\n+    mu_assert(\"Loaded histogram is null\", loaded_histogram !\u003d NULL);\n+    int compare_result \u003d memcmp(raw_histogram, loaded_histogram, raw_histogram_size);\n \n-//     return 0;\n-// }\n+    mu_assert(\"Comparison did not match\", compare_result \u003d\u003d 0);\n+\n+    return 0;\n+}\n \n static struct mu_result all_tests()\n {\n@@ -396,6 +403,7 @@\n     mu_run_test(test_logarithmic_values);\n     mu_run_test(test_reset);\n     mu_run_test(test_encode_and_decode);\n+    mu_run_test(test_encode_and_decode_compressed);\n \n     mu_ok;\n }\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Signed integer overflow for expression \u00273600L*1000*1000\u0027.",
    "cwe": "190",
    "info": "Integer overflow",
    "hashId": "0a268d3f31a112add33189a643169d72357a84f43c773d47cab266b8ec486135",
    "toolName": "cppcheck",
    "warningMessage": "Signed integer overflow for expression \u00273600L*1000*1000\u0027.",
    "warningSeverity": "error",
    "warningType": "integerOverflow",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\test\\c\\hdr_histogram_test.c",
    "lineNumber": "36",
    "columnNumber": "29",
    "commitId": "76b1b6470847ae894e6f83e33b469462d3755da9",
    "commitChildId": "956f152c6542d8e7e8912e39b461ca101e98b1c1",
    "commitTitle": "[C] Implement log iterator",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/956f152c6542d8e7e8912e39b461ca101e98b1c1",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/76b1b6470847ae894e6f83e33b469462d3755da9/src/test/c/hdr_histogram_test.c#L36",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_test.c b/src/test/c/hdr_histogram_test.c\nindex b48bc96..66151dd 100644\n--- a/src/test/c/hdr_histogram_test.c\n+++ b/src/test/c/hdr_histogram_test.c\n@@ -33,14 +33,14 @@\n         free(raw_histogram);\n     }\n \n-    hdrh_alloc(100000000, 3, \u0026raw_histogram);\n+    hdrh_alloc(3600L * 1000 * 1000, 3, \u0026raw_histogram);\n \n     if (cor_histogram)\n     {\n         free(cor_histogram);\n     }\n \n-    hdrh_alloc(100000000, 3, \u0026cor_histogram);\n+    hdrh_alloc(3600L * 1000 * 1000, 3, \u0026cor_histogram);\n \n     for (i \u003d 0; i \u003c 10000; i++)\n     {\n@@ -225,8 +225,6 @@\n \n     // Corrected Histogram\n \n-    FILE* file \u003d fopen(\"/tmp/c_cor_linear.txt\", \"w+\");\n-\n     hdrh_linear_iter_init(\u0026iter, cor_histogram, 10000);\n     index \u003d 0;\n     int64_t total_added_count \u003d 0;\n@@ -241,29 +239,60 @@\n \n         total_added_count +\u003d count_added_in_this_bucket;\n         index++;\n-\n-        fprintf(file, \"%d,%ld,%ld\\n\", index, iter.iter.value_from_index, iter.iter.count_at_index);\n     }\n-\n-    fflush(file);\n-    fclose(file);\n-\n     mu_assert(\"Should of met 10001 values\", index \u003d\u003d 10000);\n     mu_assert(\"Should of met 20000 counts\", total_added_count \u003d\u003d 20000);\n \n     return 0;\n }\n \n-static void foo(int64_t* a)\n+static char* test_logarithmic_values()\n {\n-    (*a)++;\n-}\n+    load_histograms();\n+    struct hdrh_log_iter iter;\n+    int index;\n \n-static char* test_foo()\n-{\n-    int64_t v \u003d 1;\n-    foo(\u0026v);\n-    mu_assert(\"Should increment\", v \u003d\u003d 2);\n+    hdrh_log_iter_init(\u0026iter, raw_histogram, 10000, 2.0);\n+    index \u003d 0;\n+\n+    while(hdrh_log_iter_next(\u0026iter))\n+    {\n+        long count_added_in_this_bucket \u003d iter.count_added_in_this_iteration_step;\n+        if (index \u003d\u003d 0)\n+        {\n+            mu_assert(\"Raw Logarithmic 10 msec bucket # 0 added a count of 10000\", 10000 \u003d\u003d count_added_in_this_bucket);\n+        }\n+        else if (index \u003d\u003d 14)\n+        {\n+            mu_assert(\"Raw Logarithmic 10 msec bucket # 14 added a count of 1\", 1 \u003d\u003d count_added_in_this_bucket);            \n+        }\n+        else\n+        {\n+            mu_assert(\"Raw Logarithmic 10 msec bucket added a count of 0\", 0 \u003d\u003d count_added_in_this_bucket);            \n+        }\n+\n+        index++;\n+    }\n+\n+    mu_assert(\"Should of seen 14 values\", index - 1 \u003d\u003d 14);\n+\n+    hdrh_log_iter_init(\u0026iter, cor_histogram, 10000, 2.0);\n+    index \u003d 0;\n+    int total_added_count \u003d 0;\n+    while (hdrh_log_iter_next(\u0026iter))\n+    {\n+        long count_added_in_this_bucket \u003d iter.count_added_in_this_iteration_step;\n+\n+        if (index \u003d\u003d 0)\n+        {\n+            mu_assert(\"Corrected Logarithmic 10 msec bucket # 0 added a count of 10001\", 10001 \u003d\u003d count_added_in_this_bucket);\n+        }\n+        total_added_count +\u003d count_added_in_this_bucket;\n+        index++;\n+    }\n+\n+    mu_assert(\"Should of seen 14 values\", index - 1 \u003d\u003d 14);\n+    mu_assert(\"Should of seen count of 20000\", total_added_count \u003d\u003d 20000);\n \n     return 0;\n }\n@@ -278,7 +307,7 @@\n     mu_run_test(test_percentiles);\n     mu_run_test(test_recorded_values);\n     mu_run_test(test_linear_values);\n-    mu_run_test(test_foo);\n+    mu_run_test(test_logarithmic_values);\n \n     mu_ok;\n }\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Signed integer overflow for expression \u00273600L*1000*1000\u0027.",
    "cwe": "190",
    "info": "Integer overflow",
    "hashId": "0a268d3f31a112add33189a643169d72357a84f43c773d47cab266b8ec486135",
    "toolName": "cppcheck",
    "warningMessage": "Signed integer overflow for expression \u00273600L*1000*1000\u0027.",
    "warningSeverity": "error",
    "warningType": "integerOverflow",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\test\\c\\hdr_histogram_test.c",
    "lineNumber": "43",
    "columnNumber": "29",
    "commitId": "76b1b6470847ae894e6f83e33b469462d3755da9",
    "commitChildId": "956f152c6542d8e7e8912e39b461ca101e98b1c1",
    "commitTitle": "[C] Implement log iterator",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/956f152c6542d8e7e8912e39b461ca101e98b1c1",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/76b1b6470847ae894e6f83e33b469462d3755da9/src/test/c/hdr_histogram_test.c#L43",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_test.c b/src/test/c/hdr_histogram_test.c\nindex b48bc96..66151dd 100644\n--- a/src/test/c/hdr_histogram_test.c\n+++ b/src/test/c/hdr_histogram_test.c\n@@ -33,14 +33,14 @@\n         free(raw_histogram);\n     }\n \n-    hdrh_alloc(100000000, 3, \u0026raw_histogram);\n+    hdrh_alloc(3600L * 1000 * 1000, 3, \u0026raw_histogram);\n \n     if (cor_histogram)\n     {\n         free(cor_histogram);\n     }\n \n-    hdrh_alloc(100000000, 3, \u0026cor_histogram);\n+    hdrh_alloc(3600L * 1000 * 1000, 3, \u0026cor_histogram);\n \n     for (i \u003d 0; i \u003c 10000; i++)\n     {\n@@ -225,8 +225,6 @@\n \n     // Corrected Histogram\n \n-    FILE* file \u003d fopen(\"/tmp/c_cor_linear.txt\", \"w+\");\n-\n     hdrh_linear_iter_init(\u0026iter, cor_histogram, 10000);\n     index \u003d 0;\n     int64_t total_added_count \u003d 0;\n@@ -241,29 +239,60 @@\n \n         total_added_count +\u003d count_added_in_this_bucket;\n         index++;\n-\n-        fprintf(file, \"%d,%ld,%ld\\n\", index, iter.iter.value_from_index, iter.iter.count_at_index);\n     }\n-\n-    fflush(file);\n-    fclose(file);\n-\n     mu_assert(\"Should of met 10001 values\", index \u003d\u003d 10000);\n     mu_assert(\"Should of met 20000 counts\", total_added_count \u003d\u003d 20000);\n \n     return 0;\n }\n \n-static void foo(int64_t* a)\n+static char* test_logarithmic_values()\n {\n-    (*a)++;\n-}\n+    load_histograms();\n+    struct hdrh_log_iter iter;\n+    int index;\n \n-static char* test_foo()\n-{\n-    int64_t v \u003d 1;\n-    foo(\u0026v);\n-    mu_assert(\"Should increment\", v \u003d\u003d 2);\n+    hdrh_log_iter_init(\u0026iter, raw_histogram, 10000, 2.0);\n+    index \u003d 0;\n+\n+    while(hdrh_log_iter_next(\u0026iter))\n+    {\n+        long count_added_in_this_bucket \u003d iter.count_added_in_this_iteration_step;\n+        if (index \u003d\u003d 0)\n+        {\n+            mu_assert(\"Raw Logarithmic 10 msec bucket # 0 added a count of 10000\", 10000 \u003d\u003d count_added_in_this_bucket);\n+        }\n+        else if (index \u003d\u003d 14)\n+        {\n+            mu_assert(\"Raw Logarithmic 10 msec bucket # 14 added a count of 1\", 1 \u003d\u003d count_added_in_this_bucket);            \n+        }\n+        else\n+        {\n+            mu_assert(\"Raw Logarithmic 10 msec bucket added a count of 0\", 0 \u003d\u003d count_added_in_this_bucket);            \n+        }\n+\n+        index++;\n+    }\n+\n+    mu_assert(\"Should of seen 14 values\", index - 1 \u003d\u003d 14);\n+\n+    hdrh_log_iter_init(\u0026iter, cor_histogram, 10000, 2.0);\n+    index \u003d 0;\n+    int total_added_count \u003d 0;\n+    while (hdrh_log_iter_next(\u0026iter))\n+    {\n+        long count_added_in_this_bucket \u003d iter.count_added_in_this_iteration_step;\n+\n+        if (index \u003d\u003d 0)\n+        {\n+            mu_assert(\"Corrected Logarithmic 10 msec bucket # 0 added a count of 10001\", 10001 \u003d\u003d count_added_in_this_bucket);\n+        }\n+        total_added_count +\u003d count_added_in_this_bucket;\n+        index++;\n+    }\n+\n+    mu_assert(\"Should of seen 14 values\", index - 1 \u003d\u003d 14);\n+    mu_assert(\"Should of seen count of 20000\", total_added_count \u003d\u003d 20000);\n \n     return 0;\n }\n@@ -278,7 +307,7 @@\n     mu_run_test(test_percentiles);\n     mu_run_test(test_recorded_values);\n     mu_run_test(test_linear_values);\n-    mu_run_test(test_foo);\n+    mu_run_test(test_logarithmic_values);\n \n     mu_ok;\n }\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cstring.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "4208ba58cc8b0c8458cfc1207866ce509bdb9390cc92d0a1944cbee75d3596aa",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cstring.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\test\\c\\hdr_histogram_test.c",
    "lineNumber": "11",
    "columnNumber": "0",
    "commitId": "739abdff48744766873d65d58e8ba21b4548d2f5",
    "commitChildId": "c482efa2d2e9b71c52b73ebc2fff6aee8672d466",
    "commitTitle": "[C] Working implementation of linear iterator",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/c482efa2d2e9b71c52b73ebc2fff6aee8672d466",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/739abdff48744766873d65d58e8ba21b4548d2f5/src/test/c/hdr_histogram_test.c#L11",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_test.c b/src/test/c/hdr_histogram_test.c\nindex e20d641..55eb226 100644\n--- a/src/test/c/hdr_histogram_test.c\n+++ b/src/test/c/hdr_histogram_test.c\n@@ -8,6 +8,8 @@\n #include \u003cstdbool.h\u003e\n #include \u003cstdlib.h\u003e\n #include \u003cmath.h\u003e\n+#include \u003cstring.h\u003e\n+#include \u003cerrno.h\u003e\n \n #include \u003cstdio.h\u003e\n #include \u003chdr_histogram.h\u003e\n@@ -197,24 +199,7 @@\n     struct hdrh_linear_iter iter;\n     int index;\n \n-    /*\n-    for (HistogramIterationValue v : rawHistogram.getHistogramData().linearBucketValues(100000)) {\n-        long countAddedInThisBucket \u003d v.getCountAddedInThisIterationStep();\n-        if (index \u003d\u003d 0) {\n-            Assert.assertEquals(\"Raw Linear 100 msec bucket # 0 added a count of 10000\",\n-                    10000, countAddedInThisBucket);\n-        } else if (index \u003d\u003d 999) {\n-            Assert.assertEquals(\"Raw Linear 100 msec bucket # 999 added a count of 1\",\n-                    1, countAddedInThisBucket);\n-        } else {\n-            Assert.assertEquals(\"Raw Linear 100 msec bucket # \" + index + \" added a count of 0\",\n-                    0 , countAddedInThisBucket);\n-        }\n-        index++;\n-    }\n-    Assert.assertEquals(1000, index - 1);\n-    */\n-\n+    // Raw Histogram\n     hdrh_linear_iter_init(\u0026iter, raw_histogram, 100000);\n     index \u003d 0;\n     while (hdrh_linear_iter_next(\u0026iter))\n@@ -236,36 +221,39 @@\n \n         index++;\n     }\n-    printf(\"Index: %d\\n\", index);\n-    mu_assert(\"Should of met 1000 values\", index - 1 \u003d\u003d 1000);\n+    mu_assert(\"Should of met 1000 values\", index \u003d\u003d 1000);\n \n-    /*\n+    // Corrected Histogram\n+\n+    FILE* file \u003d fopen(\"/tmp/c_cor_linear.txt\", \"w+\");\n+\n+    hdrh_linear_iter_init(\u0026iter, cor_histogram, 10000);\n     index \u003d 0;\n-    long totalAddedCounts \u003d 0;\n-    // Iterate data using linear buckets of 1 sec each.\n-    for (HistogramIterationValue v : histogram.getHistogramData().recordedValues()) {\n-        long countAddedInThisBucket \u003d v.getCountAddedInThisIterationStep();\n-        if (index \u003d\u003d 0) {\n-            Assert.assertEquals(\"Recorded bucket # 0 [\" +\n-                    v.getValueIteratedFrom() + \"..\" + v.getValueIteratedTo() +\n-                    \"] added a count of 10000\",\n-                    10000, countAddedInThisBucket);\n+    int64_t total_added_count \u003d 0;\n+    while (hdrh_linear_iter_next(\u0026iter))\n+    {\n+        int64_t count_added_in_this_bucket \u003d iter.count_added_in_this_iteration_step;\n+\n+        if (index \u003d\u003d 0)\n+        {\n+            mu_assert(\"Count at 0 is not 10001\", count_added_in_this_bucket \u003d\u003d 10001);\n         }\n-        Assert.assertTrue(\"The count in recorded bucket #\" + index + \" is not 0\",\n-                v.getCountAtValueIteratedTo() !\u003d 0);\n-        Assert.assertEquals(\"The count in recorded bucket #\" + index +\n-                \" is exactly the amount added since the last iteration \",\n-                v.getCountAtValueIteratedTo(), v.getCountAddedInThisIterationStep());\n-        totalAddedCounts +\u003d v.getCountAddedInThisIterationStep();\n+\n+        total_added_count +\u003d count_added_in_this_bucket;\n         index++;\n+\n+        fprintf(file, \"%d,%ld,%ld\\n\", index, iter.iter.value_from_index, iter.iter.count_at_index);\n     }\n-    Assert.assertEquals(\"Total added counts should be 20000\", 20000, totalAddedCounts);\n-    */\n+\n+    fflush(file);\n+    fclose(file);\n+\n+    mu_assert(\"Should of met 10001 values\", index \u003d\u003d 10000);\n+    mu_assert(\"Should of met 20000 counts\", total_added_count \u003d\u003d 20000);\n \n     return 0;\n }\n \n-\n static struct mu_result all_tests()\n {\n     mu_run_test(test_create);\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003cerrno.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "b251ec4bd7eefa27ac146b15f2953cf914eb066d49d880ae247fd3acb4da1a37",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003cerrno.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\test\\c\\hdr_histogram_test.c",
    "lineNumber": "12",
    "columnNumber": "0",
    "commitId": "739abdff48744766873d65d58e8ba21b4548d2f5",
    "commitChildId": "c482efa2d2e9b71c52b73ebc2fff6aee8672d466",
    "commitTitle": "[C] Working implementation of linear iterator",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/c482efa2d2e9b71c52b73ebc2fff6aee8672d466",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/739abdff48744766873d65d58e8ba21b4548d2f5/src/test/c/hdr_histogram_test.c#L12",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_test.c b/src/test/c/hdr_histogram_test.c\nindex e20d641..55eb226 100644\n--- a/src/test/c/hdr_histogram_test.c\n+++ b/src/test/c/hdr_histogram_test.c\n@@ -8,6 +8,8 @@\n #include \u003cstdbool.h\u003e\n #include \u003cstdlib.h\u003e\n #include \u003cmath.h\u003e\n+#include \u003cstring.h\u003e\n+#include \u003cerrno.h\u003e\n \n #include \u003cstdio.h\u003e\n #include \u003chdr_histogram.h\u003e\n@@ -197,24 +199,7 @@\n     struct hdrh_linear_iter iter;\n     int index;\n \n-    /*\n-    for (HistogramIterationValue v : rawHistogram.getHistogramData().linearBucketValues(100000)) {\n-        long countAddedInThisBucket \u003d v.getCountAddedInThisIterationStep();\n-        if (index \u003d\u003d 0) {\n-            Assert.assertEquals(\"Raw Linear 100 msec bucket # 0 added a count of 10000\",\n-                    10000, countAddedInThisBucket);\n-        } else if (index \u003d\u003d 999) {\n-            Assert.assertEquals(\"Raw Linear 100 msec bucket # 999 added a count of 1\",\n-                    1, countAddedInThisBucket);\n-        } else {\n-            Assert.assertEquals(\"Raw Linear 100 msec bucket # \" + index + \" added a count of 0\",\n-                    0 , countAddedInThisBucket);\n-        }\n-        index++;\n-    }\n-    Assert.assertEquals(1000, index - 1);\n-    */\n-\n+    // Raw Histogram\n     hdrh_linear_iter_init(\u0026iter, raw_histogram, 100000);\n     index \u003d 0;\n     while (hdrh_linear_iter_next(\u0026iter))\n@@ -236,36 +221,39 @@\n \n         index++;\n     }\n-    printf(\"Index: %d\\n\", index);\n-    mu_assert(\"Should of met 1000 values\", index - 1 \u003d\u003d 1000);\n+    mu_assert(\"Should of met 1000 values\", index \u003d\u003d 1000);\n \n-    /*\n+    // Corrected Histogram\n+\n+    FILE* file \u003d fopen(\"/tmp/c_cor_linear.txt\", \"w+\");\n+\n+    hdrh_linear_iter_init(\u0026iter, cor_histogram, 10000);\n     index \u003d 0;\n-    long totalAddedCounts \u003d 0;\n-    // Iterate data using linear buckets of 1 sec each.\n-    for (HistogramIterationValue v : histogram.getHistogramData().recordedValues()) {\n-        long countAddedInThisBucket \u003d v.getCountAddedInThisIterationStep();\n-        if (index \u003d\u003d 0) {\n-            Assert.assertEquals(\"Recorded bucket # 0 [\" +\n-                    v.getValueIteratedFrom() + \"..\" + v.getValueIteratedTo() +\n-                    \"] added a count of 10000\",\n-                    10000, countAddedInThisBucket);\n+    int64_t total_added_count \u003d 0;\n+    while (hdrh_linear_iter_next(\u0026iter))\n+    {\n+        int64_t count_added_in_this_bucket \u003d iter.count_added_in_this_iteration_step;\n+\n+        if (index \u003d\u003d 0)\n+        {\n+            mu_assert(\"Count at 0 is not 10001\", count_added_in_this_bucket \u003d\u003d 10001);\n         }\n-        Assert.assertTrue(\"The count in recorded bucket #\" + index + \" is not 0\",\n-                v.getCountAtValueIteratedTo() !\u003d 0);\n-        Assert.assertEquals(\"The count in recorded bucket #\" + index +\n-                \" is exactly the amount added since the last iteration \",\n-                v.getCountAtValueIteratedTo(), v.getCountAddedInThisIterationStep());\n-        totalAddedCounts +\u003d v.getCountAddedInThisIterationStep();\n+\n+        total_added_count +\u003d count_added_in_this_bucket;\n         index++;\n+\n+        fprintf(file, \"%d,%ld,%ld\\n\", index, iter.iter.value_from_index, iter.iter.count_at_index);\n     }\n-    Assert.assertEquals(\"Total added counts should be 20000\", 20000, totalAddedCounts);\n-    */\n+\n+    fflush(file);\n+    fclose(file);\n+\n+    mu_assert(\"Should of met 10001 values\", index \u003d\u003d 10000);\n+    mu_assert(\"Should of met 20000 counts\", total_added_count \u003d\u003d 20000);\n \n     return 0;\n }\n \n-\n static struct mu_result all_tests()\n {\n     mu_run_test(test_create);\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Signed integer overflow for expression \u002724*60*60*1000000L\u0027.",
    "cwe": "190",
    "info": "Integer overflow",
    "hashId": "a23be2a70f3cf82c811e4d53ee04af5c4abe7a491f0c5a98153bdef898642a85",
    "toolName": "cppcheck",
    "warningMessage": "Signed integer overflow for expression \u002724*60*60*1000000L\u0027.",
    "warningSeverity": "error",
    "warningType": "integerOverflow",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\test\\c\\hdr_histogram_perf.c",
    "lineNumber": "30",
    "columnNumber": "38",
    "commitId": "b619f348e840a42d935c4dfacbf852faff3653c9",
    "commitChildId": "6ef6d476f630fb0b1786348574cf5c149bde3e60",
    "commitTitle": "[C] Add optimisation flags and allow debug, optimisation and compiler to be set from the command line",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/6ef6d476f630fb0b1786348574cf5c149bde3e60",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/b619f348e840a42d935c4dfacbf852faff3653c9/src/test/c/hdr_histogram_perf.c#L30",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_perf.c b/src/test/c/hdr_histogram_perf.c\nindex b07d7f9..e61ae78 100644\n--- a/src/test/c/hdr_histogram_perf.c\n+++ b/src/test/c/hdr_histogram_perf.c\n@@ -27,7 +27,7 @@\n int main(int argc, char **argv)\n {\n     struct hdr_histogram* histogram;\n-    int64_t max_value \u003d 24 * 60 * 60 * 1000000;\n+    int64_t max_value \u003d 24 * 60 * 60 * 1000000L;\n     int result \u003d hdrh_alloc(max_value, 4, \u0026histogram);\n     if (result !\u003d 0)\n     {\n@@ -38,11 +38,12 @@\n     struct timespec t0;\n     struct timespec t1;\n     setlocale(LC_NUMERIC, \"\");\n+    int64_t iterations \u003d 400000000;\n \n     for (int i \u003d 0; i \u003c 100; i++)\n     {\n         clock_gettime(CLOCK_MONOTONIC_RAW, \u0026t0);\n-        for (int64_t j \u003d 1; j \u003c max_value; j++)\n+        for (int64_t j \u003d 1; j \u003c iterations; j++)\n         {\n             hdrh_record_value(histogram, j);\n         }\n@@ -51,7 +52,7 @@\n \n         struct timespec taken \u003d diff(t0, t1);\n         double time_taken \u003d taken.tv_sec + taken.tv_nsec / 1000000000.0;\n-        double ops_sec \u003d (max_value - 1) / time_taken;\n+        double ops_sec \u003d (iterations - 1) / time_taken;\n \n         printf(\"%s - %d, ops/sec: %\u0027.2f\\n\", \"Iteration\", i + 1, ops_sec);\n     }\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "long result is assigned to long long variable. If the variable is long long to avoid loss of information, then there is loss of information. To avoid loss of information you must cast a calculation operand to long long, for example \u0027l \u003d a * b;\u0027 \u003d\u003e \u0027l \u003d (long long)a * b;\u0027.",
    "cwe": "197",
    "hashId": "7f2f91f837dbee90e6a0326a7189688effd9928447e6484ecd428fd2e346396a",
    "toolName": "cppcheck",
    "warningMessage": "long result is assigned to long long variable. If the variable is long long to avoid loss of information, then you have loss of information.",
    "warningSeverity": "style",
    "warningType": "truncLongCastAssignment",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\test\\c\\hdr_histogram_perf.c",
    "lineNumber": "30",
    "columnNumber": "23",
    "commitId": "b619f348e840a42d935c4dfacbf852faff3653c9",
    "commitChildId": "6ef6d476f630fb0b1786348574cf5c149bde3e60",
    "commitTitle": "[C] Add optimisation flags and allow debug, optimisation and compiler to be set from the command line",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/6ef6d476f630fb0b1786348574cf5c149bde3e60",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/b619f348e840a42d935c4dfacbf852faff3653c9/src/test/c/hdr_histogram_perf.c#L30",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_perf.c b/src/test/c/hdr_histogram_perf.c\nindex b07d7f9..e61ae78 100644\n--- a/src/test/c/hdr_histogram_perf.c\n+++ b/src/test/c/hdr_histogram_perf.c\n@@ -27,7 +27,7 @@\n int main(int argc, char **argv)\n {\n     struct hdr_histogram* histogram;\n-    int64_t max_value \u003d 24 * 60 * 60 * 1000000;\n+    int64_t max_value \u003d 24 * 60 * 60 * 1000000L;\n     int result \u003d hdrh_alloc(max_value, 4, \u0026histogram);\n     if (result !\u003d 0)\n     {\n@@ -38,11 +38,12 @@\n     struct timespec t0;\n     struct timespec t1;\n     setlocale(LC_NUMERIC, \"\");\n+    int64_t iterations \u003d 400000000;\n \n     for (int i \u003d 0; i \u003c 100; i++)\n     {\n         clock_gettime(CLOCK_MONOTONIC_RAW, \u0026t0);\n-        for (int64_t j \u003d 1; j \u003c max_value; j++)\n+        for (int64_t j \u003d 1; j \u003c iterations; j++)\n         {\n             hdrh_record_value(histogram, j);\n         }\n@@ -51,7 +52,7 @@\n \n         struct timespec taken \u003d diff(t0, t1);\n         double time_taken \u003d taken.tv_sec + taken.tv_nsec / 1000000000.0;\n-        double ops_sec \u003d (max_value - 1) / time_taken;\n+        double ops_sec \u003d (iterations - 1) / time_taken;\n \n         printf(\"%s - %d, ops/sec: %\u0027.2f\\n\", \"Iteration\", i + 1, ops_sec);\n     }\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003ctime.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "e184df0f37bdcb747a81c6e63a9b11d6fa4ea699be7264cfe16e94009cd3197f",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003ctime.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\test\\c\\hdr_histogram_perf.c",
    "lineNumber": "8",
    "columnNumber": "0",
    "commitId": "ac66bb35eb20b9441b3d4124c28f1717acaf58a8",
    "commitChildId": "b619f348e840a42d935c4dfacbf852faff3653c9",
    "commitTitle": "[C] Add simple performance test and use -O3 as compilation option",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/b619f348e840a42d935c4dfacbf852faff3653c9",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ac66bb35eb20b9441b3d4124c28f1717acaf58a8/src/test/c/hdr_histogram_perf.c#L8",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_perf.c b/src/test/c/hdr_histogram_perf.c\nnew file mode 100644\nindex 0000000..b07d7f9\n--- /dev/null\n+++ b/src/test/c/hdr_histogram_perf.c\n@@ -0,0 +1,60 @@\n+#include \u003cstdint.h\u003e\n+#include \u003cstdbool.h\u003e\n+#include \u003cstdlib.h\u003e\n+#include \u003cmath.h\u003e\n+\n+#include \u003cstdio.h\u003e\n+#include \u003chdr_histogram.h\u003e\n+#include \u003ctime.h\u003e\n+#include \u003clocale.h\u003e\n+\n+struct timespec diff(struct timespec start, struct timespec end)\n+{\n+    struct timespec temp;\n+    if ((end.tv_nsec-start.tv_nsec) \u003c 0) \n+    {\n+        temp.tv_sec \u003d end.tv_sec - start.tv_sec - 1;\n+        temp.tv_nsec \u003d 1000000000 + end.tv_nsec-start.tv_nsec;\n+    }\n+    else \n+    {\n+        temp.tv_sec \u003d end.tv_sec - start.tv_sec;\n+        temp.tv_nsec \u003d end.tv_nsec - start.tv_nsec;\n+    }\n+    return temp;\n+}\n+\n+int main(int argc, char **argv)\n+{\n+    struct hdr_histogram* histogram;\n+    int64_t max_value \u003d 24 * 60 * 60 * 1000000;\n+    int result \u003d hdrh_alloc(max_value, 4, \u0026histogram);\n+    if (result !\u003d 0)\n+    {\n+        fprintf(stderr, \"Failed to allocate histogram: %d\\n\", result);\n+        return -1;\n+    }\n+\n+    struct timespec t0;\n+    struct timespec t1;\n+    setlocale(LC_NUMERIC, \"\");\n+\n+    for (int i \u003d 0; i \u003c 100; i++)\n+    {\n+        clock_gettime(CLOCK_MONOTONIC_RAW, \u0026t0);\n+        for (int64_t j \u003d 1; j \u003c max_value; j++)\n+        {\n+            hdrh_record_value(histogram, j);\n+        }\n+        clock_gettime(CLOCK_MONOTONIC_RAW, \u0026t1);\n+\n+\n+        struct timespec taken \u003d diff(t0, t1);\n+        double time_taken \u003d taken.tv_sec + taken.tv_nsec / 1000000000.0;\n+        double ops_sec \u003d (max_value - 1) / time_taken;\n+\n+        printf(\"%s - %d, ops/sec: %\u0027.2f\\n\", \"Iteration\", i + 1, ops_sec);\n+    }\n+\n+    return 0;\n+}\n"
  },
  {
    "cppcheck_version": "2.12.0",
    "verbose": "Include file: \u003clocale.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "hashId": "7c785561f9328c64310b091e1e13edb94e07895ff3b6e9c9105f5b8e91dbbaf1",
    "toolName": "cppcheck",
    "warningMessage": "Include file: \u003clocale.h\u003e not found. Please note: Cppcheck does not need standard library headers to get proper results.",
    "warningSeverity": "information",
    "warningType": "missingIncludeSystem",
    "filePath": "tmp_github\\HdrHistogram_c\\src\\test\\c\\hdr_histogram_perf.c",
    "lineNumber": "9",
    "columnNumber": "0",
    "commitId": "ac66bb35eb20b9441b3d4124c28f1717acaf58a8",
    "commitChildId": "b619f348e840a42d935c4dfacbf852faff3653c9",
    "commitTitle": "[C] Add simple performance test and use -O3 as compilation option",
    "githubFixLink": "https://github.com/HdrHistogram/HdrHistogram_c/commit/b619f348e840a42d935c4dfacbf852faff3653c9",
    "warningTraceLink": "https://github.com/HdrHistogram/HdrHistogram_c/blob/ac66bb35eb20b9441b3d4124c28f1717acaf58a8/src/test/c/hdr_histogram_perf.c#L9",
    "gitDiffText": "diff --git a/src/test/c/hdr_histogram_perf.c b/src/test/c/hdr_histogram_perf.c\nnew file mode 100644\nindex 0000000..b07d7f9\n--- /dev/null\n+++ b/src/test/c/hdr_histogram_perf.c\n@@ -0,0 +1,60 @@\n+#include \u003cstdint.h\u003e\n+#include \u003cstdbool.h\u003e\n+#include \u003cstdlib.h\u003e\n+#include \u003cmath.h\u003e\n+\n+#include \u003cstdio.h\u003e\n+#include \u003chdr_histogram.h\u003e\n+#include \u003ctime.h\u003e\n+#include \u003clocale.h\u003e\n+\n+struct timespec diff(struct timespec start, struct timespec end)\n+{\n+    struct timespec temp;\n+    if ((end.tv_nsec-start.tv_nsec) \u003c 0) \n+    {\n+        temp.tv_sec \u003d end.tv_sec - start.tv_sec - 1;\n+        temp.tv_nsec \u003d 1000000000 + end.tv_nsec-start.tv_nsec;\n+    }\n+    else \n+    {\n+        temp.tv_sec \u003d end.tv_sec - start.tv_sec;\n+        temp.tv_nsec \u003d end.tv_nsec - start.tv_nsec;\n+    }\n+    return temp;\n+}\n+\n+int main(int argc, char **argv)\n+{\n+    struct hdr_histogram* histogram;\n+    int64_t max_value \u003d 24 * 60 * 60 * 1000000;\n+    int result \u003d hdrh_alloc(max_value, 4, \u0026histogram);\n+    if (result !\u003d 0)\n+    {\n+        fprintf(stderr, \"Failed to allocate histogram: %d\\n\", result);\n+        return -1;\n+    }\n+\n+    struct timespec t0;\n+    struct timespec t1;\n+    setlocale(LC_NUMERIC, \"\");\n+\n+    for (int i \u003d 0; i \u003c 100; i++)\n+    {\n+        clock_gettime(CLOCK_MONOTONIC_RAW, \u0026t0);\n+        for (int64_t j \u003d 1; j \u003c max_value; j++)\n+        {\n+            hdrh_record_value(histogram, j);\n+        }\n+        clock_gettime(CLOCK_MONOTONIC_RAW, \u0026t1);\n+\n+\n+        struct timespec taken \u003d diff(t0, t1);\n+        double time_taken \u003d taken.tv_sec + taken.tv_nsec / 1000000000.0;\n+        double ops_sec \u003d (max_value - 1) / time_taken;\n+\n+        printf(\"%s - %d, ops/sec: %\u0027.2f\\n\", \"Iteration\", i + 1, ops_sec);\n+    }\n+\n+    return 0;\n+}\n"
  }
]